/************************************ GRID ************************************/
/* Functions and variables related to the grid interface.                     */
/******************************************************************************/
// A mutex is required for `numberOfRows(int)` to handle users double-clicking
// the 'Add Row' and 'Delete Row' buttons.
MUTEX_WALKER_UNIT_ROWS = new Semaphore(1);

final String ATTRIB_ANCIENT         = "Ancient";
final String ATTRIB_HAS_INITIALS    = "hasInitials";
final String ATTRIB_IDENTIFIER      = "Identifier";
final String ATTRIB_INITIALS        = "Initials";
final String ATTRIB_IS_CONFIRMED    = "isConfirmed";
final String ATTRIB_IS_HIGHLIGHTED  = "isHighlighted";
final String ATTRIB_IS_MAIN         = "isMain";
final String ATTRIB_IS_NA           = "isNa";
final String ATTRIB_IS_ROW_INDEX    = "isRowIndex";
final String ATTRIB_IS_SELECTED     = "isSelected";
final String ATTRIB_IS_SIDE         = "isSide";
final String ATTRIB_IS_WALKER_INDEX = "isWalkerIndex";
final String ATTRIB_MODERN          = "Modern";
final String ATTRIB_NA              = "N A";
final String ATTRIB_UUID            = "UUID";

List getCountAttribs1() {
  List l = new ArrayList();
  l.add("Ancient");
  l.add("Daub");
  l.add("HM");
  return l;
}

List getCountAttribs2() {
  return getZeroableAttribNames();
}

/******************************* GRID - CACHING *******************************/
// `GRID_CACHE` is a 2-d array. The first two dimensions are the rows and
// walkers, respectively. Each element accessed by an index, (row, walker),
// contains a map from `vocabname` to its value (either the measure or vocabid.
Map[][] GRID_CACHE = null;
AtomicInteger NUM_RUNNING_GRID_UPDATES   = new AtomicInteger(0);
AtomicInteger NUM_RUNNING_WALKER_UPDATES = new AtomicInteger(0);

// These two variables determine the size of the cache.
int GRID_MAX_WIDTH  = 20;
int GRID_MAX_HEIGHT = 25;

void initGridCache() {
  GRID_CACHE = new HashMap[GRID_MAX_HEIGHT][GRID_MAX_WIDTH];

  // Update data about the user's interactions during this session
  for   (int i = 0; i < GRID_MAX_HEIGHT; i++) {
    for (int j = 0; j < GRID_MAX_WIDTH;  j++) {
      updateGridCache(i, j);
    }
  }
}

String getGridCacheUpdateQuery(String uuid, boolean byParentUuid) {
  String parentJoin = byParentUuid ?
    " join parentchild on (childuuid = uuid)" :
    "";

  String whereClause = byParentUuid ?
    " where parentuuid = {uuid}" :
    " where uuid       = {uuid}";

  String q = "";
  q += " select";
  q += "     uuid,";
  q += "     rowNumber,";
  q += "     walkerNumber,";
  q += "     SUM(CASE WHEN attributename IN {cnt_attrs_1} THEN measure ELSE 0 END),";
  q += "     SUM(CASE WHEN attributename IN {cnt_attrs_2} THEN measure ELSE 0 END),";
  q += "     MAX(CASE WHEN attributename = 'N A' AND vocabid IS NOT NULL THEN 1 ELSE NULL END)";
  q += " from latestnondeletedaentvalue join attributekey using (attributeid)";
  q += parentJoin;
  q += " join (select uuid, measure as walkerNumber, valuetimestamp as footimestamp";
  q += "     from latestnondeletedaentvalue";
  q += "     join attributekey using (attributeid)";
  q += "     where attributename = 'Walker Number') USING (uuid)";
  q += " join (select uuid, measure as rowNumber";
  q += "     from latestnondeletedaentvalue";
  q += "     join attributekey using (attributeid)";
  q += "     where attributename = 'Row Number') USING (uuid)";
  q += whereClause;
  q += " group by uuid, rowNumber, walkerNumber";
  q += " order by footimestamp, rowNumber, walkerNumber, attributename";

  q  = replaceFirst(q, "{cnt_attrs_1}", listToSqlString(getCountAttribs1()));
  q  = replaceFirst(q, "{cnt_attrs_2}", listToSqlString(getCountAttribs2()));
  q  = replaceFirst(q, "{uuid}", uuid);

  return q;
}

/* The grid is a 2-d array. The first two dimensions are the rows and walkers,
 * respectively. Each element accessed by an index, (row, walker), contains a
 * map of statistics. In other words, `GRID_CACHE.get(0).get(0)` is a Map.
 */
void updateGridCache() {
  updateGridCache("redrawGrid()");
}

void updateGridCache(String callback) {
  NUM_RUNNING_GRID_UPDATES.incrementAndGet();

  String parentTabGroup = "Survey_Unit";
  String parentUuid     = getUuid(parentTabGroup);

  String q = getGridCacheUpdateQuery(parentUuid, true);

  FetchCallback updateGridCache = new FetchCallback() {
    onFetch(result) {
      initGridCache();
      updateGridCache(result);
      NUM_RUNNING_GRID_UPDATES.decrementAndGet();
      execute(callback);
    }
  };

  fetchAll(q, updateGridCache);
}

void updateGridCache(Object result) {
  if (result == null) return;

  // Insert 'Walker Unit' data from database
  for (dbRow : result) {
    String       uuid     =             dbRow.get(0) ;
    String     sRowNumber =             dbRow.get(1) ;
    int        iRowNumber = stringToInt(dbRow.get(1));
    String  sWalkerNumber =             dbRow.get(2) ;
    int     iWalkerNumber = stringToInt(dbRow.get(2));
    String ancient        =             dbRow.get(3) ;
    String modern         =             dbRow.get(4) ;
    String na             =             dbRow.get(5) ;

    if (!isValidInt(   sRowNumber)) continue;
    if (!isValidInt(sWalkerNumber)) continue;
    if (   iRowNumber > GRID_MAX_HEIGHT) continue;
    if (iWalkerNumber > GRID_MAX_WIDTH ) continue;
    if (   iRowNumber < 1) continue;
    if (iWalkerNumber < 1) continue;

    updateGridCache(iRowNumber, iWalkerNumber, ATTRIB_UUID,    uuid);
    updateGridCache(iRowNumber, iWalkerNumber, ATTRIB_ANCIENT, ancient);
    updateGridCache(iRowNumber, iWalkerNumber, ATTRIB_MODERN,  modern);
    updateGridCache(iRowNumber, iWalkerNumber, ATTRIB_NA,      na);
  }
}

// Updates the "pre-computed facts". Does not access the database.
void updateGridCache(int i, int j) {
  updateGridCache(i, j, "", "");
}

void updateGridCache(int i, int j, String attribName, attribVal) {
  Log.d("updateGridCache", i + " " + j + " " + attribName + " " + attribVal);
  if (attribVal == null)
    return;
  if (GRID_CACHE == null)
    initGridCache();

  final Boolean TRUE = new Boolean(true);

  final String DEFAULT_ANCIENT  = "0";
  final String DEFAULT_INITIALS = "&mdash;";
  final String DEFAULT_MODERN   = "0";
  final String DEFAULT_NA       = "N/A";

  // 1. Get the  `cell` from `GRID_CACHE`.
  Map cell = GRID_CACHE[i][j];
  if (cell == null) {
    cell = new HashMap();
    GRID_CACHE[i][j] = cell;
  }

  if (!isNull(attribName))
    cell.put(attribName, attribVal);

  // 2. Compute old/default attribute values
  Boolean isHighlighted = TRUE.equals(cell.get(ATTRIB_IS_HIGHLIGHTED));
  Boolean isSelected    = TRUE.equals(cell.get(ATTRIB_IS_SELECTED));
  Boolean isRowIndex    = (i >  0 && j == 0);
  Boolean isWalkerIndex = (i == 0 && j >  0);
  Boolean isSide        = (i == 0 || j == 0);
  Boolean isMain        = !isSide;
  Boolean isConfirmed   = isMain && TRUE.equals(cell.get(ATTRIB_IS_CONFIRMED))
                                 || attribName.equals(ATTRIB_ANCIENT)
                                 || attribName.equals(ATTRIB_MODERN);
  Boolean isNa          =
      !ATTRIB_NA.equals(attribName) && TRUE.equals(cell.get(ATTRIB_IS_NA)) ||
       ATTRIB_NA.equals(attribName) && !isNull(attribVal);
  Boolean hasInitials   = !isNull(cell.get(ATTRIB_INITIALS)) &&
                          !DEFAULT_INITIALS.equals(
                                  cell.get(ATTRIB_INITIALS));

  String na             = isNa ? DEFAULT_NA : "";
  String ancient        = cell.get(ATTRIB_ANCIENT) != null ?
                          cell.get(ATTRIB_ANCIENT) : DEFAULT_ANCIENT;
  String modern         = cell.get(ATTRIB_MODERN) != null ?
                          cell.get(ATTRIB_MODERN) : DEFAULT_MODERN;
  String initials       = hasInitials ? cell.get(ATTRIB_INITIALS) :
                          DEFAULT_INITIALS;

  // 6. `put` the computed values
  cell.put(ATTRIB_ANCIENT         , ancient      );
  cell.put(ATTRIB_HAS_INITIALS    , hasInitials  );
  cell.put(ATTRIB_INITIALS        , initials     );
  cell.put(ATTRIB_IS_CONFIRMED    , isConfirmed  );
  cell.put(ATTRIB_IS_HIGHLIGHTED  , isHighlighted);
  cell.put(ATTRIB_IS_MAIN         , isMain       );
  cell.put(ATTRIB_IS_NA           , isNa         );
  cell.put(ATTRIB_IS_ROW_INDEX    , isRowIndex   );
  cell.put(ATTRIB_IS_SELECTED     , isSelected   );
  cell.put(ATTRIB_IS_SIDE         , isSide       );
  cell.put(ATTRIB_IS_WALKER_INDEX , isWalkerIndex);
  cell.put(ATTRIB_MODERN          , modern       );
  cell.put(ATTRIB_NA              , na           );
}

void updateGridCacheFromUuid(String uuid) {
  updateGridCacheFromUuid(uuid, "");
}

void updateGridCacheFromUuid(String parentUuid, String uuid, String callback) {
  NUM_RUNNING_GRID_UPDATES.incrementAndGet();

  String q = getGridCacheUpdateQuery(uuid, false);

  FetchCallback updateGridCache = new FetchCallback() {
    onFetch(result) {
      // Prevents updating the grid of an old survey unit. This can happen if
      // you make a change to a walker unit then tap the "Next Survey Unit"
      // before the changes were saved.
      boolean gridIsCurrent = parentUuid == null
        || parentUuid.equals(getUuid("Survey_Unit"));

      if (gridIsCurrent) {
        // Reset "isNa" to its default value
        for (r : result) {
          int rowNumber    = stringToInt(r.get(1));
          int walkerNumber = stringToInt(r.get(2));

          updateGridCache(rowNumber, walkerNumber, ATTRIB_NA, "");
          continue;
        }

        updateGridCache(result);
      }

      NUM_RUNNING_GRID_UPDATES.decrementAndGet();
      execute(callback);
    }
  };

  fetchAll(q, updateGridCache);
}

void deselectAll() {
  int I = -1 + GRID_MAX_HEIGHT;
  int J = -1 + GRID_MAX_WIDTH;
  deselectAll(I, J);
}

void unhighlightAll() {
  int I = -1 + GRID_MAX_HEIGHT;
  int J = -1 + GRID_MAX_WIDTH;
  unhighlightAll(I, J);
}

void deselectAll(int I, int J) {
  setGridInRange(I, J, ATTRIB_IS_SELECTED, false);
}

void unhighlightAll(int I, int J) {
  setGridInRange(I, J, ATTRIB_IS_HIGHLIGHTED, false);
}

void setGridInRange(int I, int J, String attribName, attribVal) {
  if (GRID_CACHE == null) return;
  for   (int i = 0; i <= I; i++)
    for (int j = 0; j <= J; j++)
      GRID_CACHE[i][j].put(attribName, attribVal);
}

void updateGridWalkers() {
  NUM_RUNNING_WALKER_UPDATES.incrementAndGet();
  String parentUuid = getUuid("Survey_Unit");

  String q = "";
  q += " SELECT `order`, initials, uuid";
  q += "         FROM (SELECT uuid, measure AS initials";
  q += "                 FROM parentchild";
  q += "                 JOIN latestnondeletedaentvalue on (childuuid = uuid)";
  q += "                 JOIN attributekey USING (attributeid)";
  q += "                WHERE parentuuid = {parentUuid}";
  q += "                  AND attributename IN ('Initials'))";
  q += "         JOIN (SELECT childuuid AS uuid, freetext AS `order`";
  q += "                 FROM parentchild";
  q += "                 JOIN latestnondeletedrelnvalue USING (relationshipid)";
  q += "                 JOIN attributekey USING (attributeid)";
  q += "                WHERE attributename = 'Order'";
  q += "                  AND parentUuid = {parentUuid}) USING (uuid)";
  q  = replaceFirst(q, "{parentUuid}", parentUuid);
  q  = replaceFirst(q, "{parentUuid}", parentUuid);

  FetchCallback updateGridWalkers = new FetchCallback() {
    onFetch(result) {
      updateGridWalkers(result);
      NUM_RUNNING_WALKER_UPDATES.decrementAndGet();
      redrawGrid();
    }
  };

  fetchAll(q, updateGridWalkers);
}

void updateGridWalkers(Object result) {
  // 1. Clear walkers
  for (int i = 0; i < GRID_MAX_WIDTH; i++) {
    updateGridCache(0, i, ATTRIB_INITIALS, "");
  }

  // 2. Insert new walkers
  for (dbRow : result) {
    String sWalkerNumber =             dbRow.get(0);
    int    iWalkerNumber = stringToInt(dbRow.get(0));
    String initials      =             dbRow.get(1);
    String uuid          =             dbRow.get(2);

    updateGridCache(0, iWalkerNumber, ATTRIB_INITIALS, initials);
    updateGridCache(0, iWalkerNumber, ATTRIB_UUID,       uuid    );
  }
}

List getWalkerRels() {
  List walkerRels = new ArrayList();

  int orderInt = 1;
  for (int i = 0; i < NUM_WALKERS; i++) {
    walker = WALKER_CACHE_CLEAN[i];
    Boolean isSel = walker.get(ATTRIB_IS_SELECTED);

    if (isSel == null) isSel = false;
    if (!isSel)        continue;

    String parentEntityRef = "Survey_Unit";
    String parentUuid      = getUuid(parentEntityRef);
    String childUuid       = walker.get(ATTRIB_UUID);
    String order           = orderInt++ + "";

    List rel = new ArrayList();
    rel.add(parentUuid);
    rel.add(childUuid);
    rel.add(order);

    walkerRels.add(rel);
  }

  return walkerRels;
}

/******************************* GRID - DRAWING *******************************/
void redrawGrid() {
  redrawGrid(false);
}

void redrawGrid(boolean doRefreshCache) {
  Log.d("redrawGrid", "Redrawing");
  if (doRefreshCache) {
    updateGridCache("redrawGrid()");
    //showWarning("", "Updating");
    return;
  }
  //showWarning("", "Redrawing");
  if (GRID_CACHE == null) {
    return;
  }

  int    numberOfRows    = numberOfRows();
  int    numberOfWalkers = numberOfWalkers();
  String refGridWebView  = "Walker_Unit/Walker_Unit/Grid";

  // In a probably vain attempt to improve performance, this code is valid
  // HTML5.
  String html = "";

  html += "<!DOCTYPE html>";
  html += "<html>";
  html += "  <head>";
  html += "    <title>Grid</title>";
  html += "    <style>";
  html += "      table {";
  html += "        table-layout: fixed;";
  html += "        border-collapse: separate;";
  html += "        border-spacing:  0px;";
  html += "        width: 100%;";
  html += "      }";
  html += "      td {";
  html += "        border: 1px solid #000000;";
  html += "        font-weight: 100;";
  html += "        padding: 2px;";
  html += "        text-align: center;";
  html += "      }";
  html += "      td.highlighted {";
  html += "        background-color: #CCCCCC;";
  html += "        border:  3px double #000000;";
  html += "        padding: 0px;";
  html += "      }";
  html += "      td.selected {";
  html += "        background-color: #77FF77;";
  html += "        color:            #000000;";
  html += "      }";
  html += "      td.row-index {";
  html += "        white-space:nowrap;";
  html += "        width: 20px;";
  html += "      }";
  html += "      td.side {";
  html += "        border: none;";
  html += "      }";
  html += "      td.confirmed {";
  html += "        text-shadow: 1px 0px #000;";
  html += "        font-weight: 900;";
  html += "      }";
  html += "    </style>";
  html += "  </head>";
  html += "  <body>";
  html += "    <table>";

  for (int i = numberOfRows; i >= 0; i--) {
    html += "      <tr>";
    for (int j = 0; j <= numberOfWalkers; j++) {
      HashMap cell = GRID_CACHE[i][j];

      Boolean hasInitials   = cell.get(ATTRIB_HAS_INITIALS);
      Boolean isConfirmed   = cell.get(ATTRIB_IS_CONFIRMED);
      Boolean isHighlighted = cell.get(ATTRIB_IS_HIGHLIGHTED);
      Boolean isMain        = cell.get(ATTRIB_IS_MAIN);
      Boolean isNa          = cell.get(ATTRIB_IS_NA);
      Boolean isRowIndex    = cell.get(ATTRIB_IS_ROW_INDEX);
      Boolean isSelected    = cell.get(ATTRIB_IS_SELECTED);
      Boolean isSide        = cell.get(ATTRIB_IS_SIDE);
      Boolean isWalkerIndex = cell.get(ATTRIB_IS_WALKER_INDEX);

      // Build the string of CSS classes to apply to this <td> element
      String  cssClass = "";
      if (isHighlighted) cssClass += " highlighted";
      if (isSelected   ) cssClass += " selected";
      if (isRowIndex   ) cssClass += " row-index";
      if (isSide       ) cssClass += " side";
      if (isConfirmed  ) cssClass += " confirmed";

      // Get the <td> values ('Modern', 'Ancient', 'N/A', ...?)
      na       = cell.get(ATTRIB_NA);
      ancient  = cell.get(ATTRIB_ANCIENT);
      modern   = cell.get(ATTRIB_MODERN);
      initials = cell.get(ATTRIB_INITIALS);

      // Build the HTML string for this <td>
      String htmlCell = "";
      htmlCell += "        <td class=\"{cssClass}\">";
      if (isRowIndex     ) htmlCell += i;
      if (isWalkerIndex  ) htmlCell += initials;
      if (isMain &&  isNa) htmlCell += na;
      if (isMain && !isNa) htmlCell += "<sup>{anc}</sup>/<sub>{mod}</sub>";
      htmlCell  = replaceFirst(htmlCell, "{cssClass}", cssClass);
      htmlCell  = replaceFirst(htmlCell, "{anc}",      ancient );
      htmlCell  = replaceFirst(htmlCell, "{mod}",      modern  );
      htmlCell += "        </td>";

      // Add the cell to the existing HTML
      html += htmlCell;
    }
    html += "      </tr>";
  }
  html += "    </table>";
  html += "  </body>";
  html += "</html>";

  // Now that the html string has been built, we can populate the web view
  populateWebViewHtml(refGridWebView, html);
}

int numberOfRows() {
  String ref = "Survey_Unit/Survey_Unit/Number_of_Rows";
  int    val = getFieldValueAsInt(ref);

  return clip(val, 0, GRID_MAX_HEIGHT);
}

/* It is assumed that this function is only ever called while "Walker_Unit" is
 * displayed.
 */
void numberOfRows(int val) {
  numberOfRows(val, "");
}

void numberOfRows(int val, String callback) {
  val = clip(val, 1, GRID_MAX_HEIGHT);

  String  refRows           = "Survey_Unit/Survey_Unit/Number_of_Rows";
  String  parentTabGroup    = getTabGroupRef(refRows);
  String  parentUuid        = getUuid       (parentTabGroup);
  String  parentArchEntType = getArchEntType(parentTabGroup);
  String  attrName          = getAttributeName(refRows);
  String  numberOfRows      = String.valueOf(val);
  List    geometry          = null;
  List    attributes        = createAttributeList();
  boolean doRehighlight     = val < highlightedRow();
  boolean doReselect        = val < selectedRow();

  if (!isDisplayed("Walker_Unit"))
    return;

  if (MUTEX_WALKER_UNIT_ROWS.drainPermits() == 0)
    return;

  // 1. Even though we're updating the database directly, we also need to update
  //    the UI.
  setFieldValue(refRows, numberOfRows);

  // 2. Update 'Number of Rows' using saveArchEnt
  SaveCallback release = new SaveCallback() {
    onSave(uuid, newRecord) {
      if (doRehighlight) {
        highlightedRow(val);
      }
      if (doReselect) {
        loadOrMakeWalkerUnit();
      }

      execute(callback);
      MUTEX_WALKER_UNIT_ROWS.release();
    }
  };

  Object a = createEntityAttribute(attrName, null, null, numberOfRows, null);
  attributes.add(a);

  // 3. Do the update step
  saveArchEnt(parentUuid, parentArchEntType, geometry, attributes, release);
}

int highlightedRow() {
  String ref = "Survey_Unit/Vars/Highlighted_Row";
  int    val = getFieldValueAsInt(ref);

  return clip(val, 1, numberOfRows());
}

void highlightedRow(int newVal) {
  String ref = "Survey_Unit/Vars/Highlighted_Row";
  int    highlightedWalker = highlightedWalker();

  int    iOldVal  = highlightedRow();

  int    iNewVal = clip(newVal, 1, numberOfRows());
  String sNewVal = String.valueOf(iNewVal);

  setFieldValue(ref, sNewVal);

  unhighlightAll();
  updateGridCache(iNewVal, highlightedWalker, ATTRIB_IS_HIGHLIGHTED, true);
}

int selectedRow() {
  String ref = "Walker_Unit/Vars/Row_Number";
  int    val = getFieldValueAsInt(ref);

  return max(1, val);
}

int numberOfWalkers() {
  String ref = "Survey_Unit/Survey_Unit/Number_of_Walkers";
  int    val = getFieldValueAsInt(ref);

  return clip(val, 0, GRID_MAX_WIDTH);
}

int highlightedWalker() {
  String ref = "Survey_Unit/Vars/Highlighted_Walker";
  int    val = getFieldValueAsInt(ref);

  return clip(val, 1, numberOfWalkers());
}

void highlightedWalker(int newVal) {
  String ref    = "Survey_Unit/Vars/Highlighted_Walker";
  int    highlightedRow = highlightedRow();

  int    iOldVal = highlightedWalker();

  int    iNewVal = clip(newVal, 1, numberOfWalkers());
  String sNewVal = String.valueOf(iNewVal);

  setFieldValue(ref, sNewVal);

  unhighlightAll();
  updateGridCache(highlightedRow, iNewVal, ATTRIB_IS_HIGHLIGHTED, true);
}

int selectedWalker() {
  String ref = "Walker_Unit/Vars/Walker_Number";
  int    val = getFieldValueAsInt(ref);

  return max(1, val);
}

void moveHighlightedWalker(int delta) {
  int numberOfWalkers   = numberOfWalkers  ();
  int highlightedWalker = highlightedWalker();

  int update = mod(
      (highlightedWalker - 1) + delta,
      numberOfWalkers
  ) + 1;

  highlightedWalker(update);
}

void moveHighlightedRow(int delta) {
  int numberOfRows   = numberOfRows  ();
  int highlightedRow = highlightedRow();

  int update = mod(
      (highlightedRow - 1) + delta,
      numberOfRows
  ) + 1;

  highlightedRow(update);
}

void initHighlighted() {
  highlightedRow   (1);
  highlightedWalker(1);
}

void gridUp   () { moveHighlightedRow   (+1); redrawGrid(); }
void gridDown () { moveHighlightedRow   (-1); redrawGrid(); }
void gridLeft () { moveHighlightedWalker(-1); redrawGrid(); }
void gridRight() { moveHighlightedWalker(+1); redrawGrid(); }
void gridRandomAccessWalker() {
  String ref          = "Walker_Unit/Walker_Unit/Load_Walker";
  int    walkerNumber = getFieldValueAsInt(ref);

  highlightedWalker(walkerNumber);
  loadOrMakeWalkerUnit();
}

/***************************** GRID - ROW ZEROING *****************************/
// A queue of the 'Walker Unit' entities which require creation and
// initialisation to zero.
WALKER_UNITS_TO_ZERO = new LinkedBlockingQueue();

// A lock on the `WALKER_UNITS_TO_ZERO` variable.
MUTEX_DEQUEUE_WALKER_UNITS = new Semaphore(1);

void zeroRowAndNext() {
  triggerAutoSave();

  int numberOfWalkers = numberOfWalkers();
  int selectedWalker  = selectedWalker();
  int selectedRow     = selectedRow();

  Set unsavedWalkerNumbers = new HashSet();

  // Populate `unsavedWalkerNumbers`
  for (int i = 1; i <= numberOfWalkers(); i++) {
    // We take "isConfirmed" to be synonymous with "is saved".
    Boolean isConfirmed = GRID_CACHE[selectedRow][i].get(ATTRIB_IS_CONFIRMED);
    if (isConfirmed != null && isConfirmed == true) continue;

    String walkerNumber = String.valueOf(i);
    unsavedWalkerNumbers.add(walkerNumber);
  }
  // We must accommodate for the fact that the currently displayed Walker Unit
  // will be saved when it is navigated away from.
  unsavedWalkerNumbers.remove(selectedWalker + "");

  // Enqueue "Walker Unit" records which were previously unsaved
  rowNumber = String.valueOf(selectedRow);
  for (String walkerNumber : unsavedWalkerNumbers) {
    String parentUuid = getUuid("Survey_Unit");

    // Pack fields
    List walkerUnitToZero = new ArrayList();
    walkerUnitToZero.add(parentUuid);
    walkerUnitToZero.add(rowNumber);
    walkerUnitToZero.add(walkerNumber);

    // Enque packed fields
    WALKER_UNITS_TO_ZERO.put(walkerUnitToZero);
  }
  // Start saving them, one at a time.
  dequeWalkerUnitsToZero();
}

/* Create 'Walker Unit' records listed in `WALKER_UNITS_TO_ZERO`.
 *
 * Notice that this function is essentially composed of two:
 *
 *   - `dequeWalkerUnitsToZero()`    --- Non-recursive part
 *   - `dequeWalkerUnitsToZeroRec()` --- Recursive part
 *
 * The function is written this way to help coordinate locking behaviour. This
 * function's uses `MUTEX_DEQUEUE_WALKER_UNITS` to lock `WALKER_UNITS_TO_ZERO`.
 */
void dequeWalkerUnitsToZero() {
  if (MUTEX_DEQUEUE_WALKER_UNITS.drainPermits() == 0) {
    return;
  }

  showTabGroup("Saving");
  dequeWalkerUnitsToZeroRec();
}

void dequeWalkerUnitsToZeroRec() {
  populateWebViewHtml("Saving/Saving/Saving", getSavingHtml());

  if (WALKER_UNITS_TO_ZERO.size() == 0) {
    MUTEX_DEQUEUE_WALKER_UNITS.release();

    Boolean doWarn = false;
    cancelTabGroup("Saving", doWarn);

    nextRow();

    return;
  }

  List walkerUnitToZero = WALKER_UNITS_TO_ZERO.take();

  // Unpack fields from queue
  String parentUuid     =             walkerUnitToZero.get(0);//Survey Unit UUID
  String     sRowNumber =             walkerUnitToZero.get(1);
  int        iRowNumber = stringToInt(walkerUnitToZero.get(1));
  String  sWalkerNumber =             walkerUnitToZero.get(2);
  int     iWalkerNumber = stringToInt(walkerUnitToZero.get(2));
  // Prepare other fields which are required to perform a save
  String uuid         = null;
  String entityType   = "Walker Unit";
  List   geometry     = null;
  List   attributes   = createZeroedAttributeList(sRowNumber, sWalkerNumber);
  SaveCallback relate = new SaveCallback() {
    onSave(uuid, newRecord) {
      saveEntitiesToHierRel(
        "Survey Unit - Walker Unit",
        parentUuid,
        uuid,
        "Parent Of",
        "Child Of",
        "dequeWalkerUnitsToZeroRec()" // Beware pitfalls! Recursive call here!
      );
    }
  };

  // Save 'Walker Unit'. This should create a new record as opposed to
  // overwriting an existing one.
  saveArchEnt(uuid, entityType, geometry, attributes, relate);
  updateGridCache(iRowNumber, iWalkerNumber, ATTRIB_IS_CONFIRMED, true);
}

String getSavingHtml() {
  String html = "";

  html += "<!DOCTYPE html>";
  html += "<html>";
  html += "  <head><title>Saving...</title></head>";
  html += "  <p>";
  html += "    <b>Please do not leave this tab group.</b>";
  html += "    The following Walker Unit records are saving:";
  html += "  </p>";
  html += "  <ul>";
  html += getSavingHtmlLis();
  html += "  </ul>";
  html += "</html>";

  return html;
}

String getSavingHtmlLis() {
  // Copy Queue object to avoid blocking
  LinkedBlockingQueue walkerUnitsToZero;
  synchronized (WALKER_UNITS_TO_ZERO) {
    walkerUnitsToZero = new LinkedBlockingQueue(WALKER_UNITS_TO_ZERO);
  }

  String html = "";
  while(!walkerUnitsToZero.isEmpty()) {
    List walkerUnitToZero = walkerUnitsToZero.take();

    // Unpack values from `walkerUnitToZero`
    String    rowNumber = walkerUnitToZero.get(1);
    String walkerNumber = walkerUnitToZero.get(2);

    // Build the <li> string
    String fmtHtmlLi = "<li>Row %s, Walker %s</li>";
    String    htmlLi = replaceFirst(fmtHtmlLi,    rowNumber);
              htmlLi = replaceFirst(   htmlLi, walkerNumber);

    // Append the <li> string
    html += htmlLi;
  }

  return html;
}

void nextRow() {
  if (selectedRow() == numberOfRows()) {
    numberOfRows(numberOfRows() + 1, "nextRow()");
  } else {
    highlightedWalker(1);
    highlightedRow   (1+selectedRow());

    loadOrMakeWalkerUnit();
  }
}

void nextWalkerUnit () {
  if (highlightedWalker() == numberOfWalkers()) {
    nextRow();
  } else {
    highlightedRow   (  selectedRow   ());
    highlightedWalker(1+selectedWalker());

    loadOrMakeWalkerUnit();
  }
}

void addRow   () { numberOfRows(numberOfRows() + 1, "redrawGrid()"); }
void deleteRow() { numberOfRows(numberOfRows() - 1, "redrawGrid()"); }

List getZeroableRefs() {
  List   elemNames = new ArrayList(); // names of zeroable elements
  List   refs      = new ArrayList(); // references of zeroable elements
  String fmtRef    = "Walker_Unit/Walker_Unit/%s";

  // 1. Write the element names
  elemNames.add("Ancient");
  elemNames.add("Modern");
  elemNames.add("A_C");
  elemNames.add("Daub");
  elemNames.add("HM");
  elemNames.add("Lithic");
  elemNames.add("Glass");
  elemNames.add("Other");

  // 2. Format the element names into refs
  for (e : elemNames) {
    String ref = replaceFirst(fmtRef, e);
    refs.add(ref);
  }

  return refs;
}

List getZeroableAttribNames() {
  List refs = getZeroableRefs();
  List attribNames = new ArrayList();

  for (String ref : refs) {
    attribNames.add(getAttributeName(ref));
  }

  return attribNames;
}

List createZeroedAttributeList(String rowNumber, String walkerNumber) {
  List attribs = createAttributeList();

  String cert = "1.0"; // Certainty, having the default value of 1.0

  // Set 'Walker Number' and 'Row Number' to given values
  attribs.add(createEntityAttribute("Walker Number", null, null, walkerNumber, cert));
  attribs.add(createEntityAttribute("Row Number",    null, null, rowNumber,    cert));

  // Set zeroable properties to zero
  for (String ref : getZeroableRefs()) {
    String attribName = getAttributeName(ref);
    attribs.add(createEntityAttribute(attribName, null, null, "0", cert));
  }

  return attribs;
}

void zeroIfBlank() {
  for (ref : getZeroableRefs()) {
    zeroIfBlank(ref);
  }
}

void zeroIfBlank(String ref) {
  String blank = "";
  String zero  = "0";
  String val   = getFieldValue(ref);
  if (blank.equals(val)) {
    setFieldValue(ref, zero);
  }
}

void blankIfZero(String ref) {
  String blank = "";
  String zero  = "0";
  String val   = getFieldValue(ref);
  if (zero.equals(val)) {
    setFieldValue(ref, blank);
  }
}

float rowInterval() {
  String ref = "Survey_Unit/Survey_Unit/Row_Interval_m";
  return getFieldValueAsFloat(ref);
}

for (ref : getZeroableRefs()) {
  String focus = "blankIfZero(\"%s\")"; focus = replaceFirst(focus, ref);
  String blur  = "zeroIfBlank(\"%s\")"; blur  = replaceFirst(blur,  ref);

  addOnEvent(ref, "focus", focus);
  addOnEvent(ref, "blur",  blur );
}

/******************************* GRID - LOADING *******************************/
void loadOrMakeWalkerUnit() {
  int highlightedRow    = highlightedRow   ();
  int highlightedWalker = highlightedWalker();
  int selectedRow       = selectedRow   ();
  int selectedWalker    = selectedWalker();

  String refWalkerUnit  = "Walker_Unit";

  // The selected walker unit is already loaded
  if (
      isDisplayed(refWalkerUnit) &&
      highlightedRow    == selectedRow &&
      highlightedWalker == selectedWalker
  ) {
    triggerAutoSave();
    return;
  }

  // Leave "Walker_Unit". This resets the highlighted cell to (1, 1).
  if (isDisplayed(refWalkerUnit))
    cancelTabGroup(refWalkerUnit, false);

  // Restore the highlighted cell. This causes any new walker unit to be made
  // with the correct Row Number and Walker Number.
  highlightedRow   (highlightedRow   );
  highlightedWalker(highlightedWalker);

  // Load or make walker unit
  String uuid = GRID_CACHE[highlightedRow][highlightedWalker].get(ATTRIB_UUID);
  if (uuid == null) {
    parentTabgroup = "Survey_Unit";
    newWalkerUnit();
  } else {
    loadWalkerUnitFrom(uuid);
  }
}

void onLoadWalkerUnit() {
  deselectAll();
  updateGridCache(selectedRow(), selectedWalker(), ATTRIB_IS_SELECTED, true);
  redrawGrid();
}

void onCreateWalkerUnit() {
  deselectAll();
  updateGridCache(highlightedRow(), highlightedWalker(), ATTRIB_IS_SELECTED,  true);
  redrawGrid();
}

addOnEvent("Walker_Unit", "fetch", "onLoadWalkerUnit()");
addOnEvent("Walker_Unit", "create", "onCreateWalkerUnit()");

void onShowWalkerUnit () {
  saveWalkerUnit();
}

void saveWalkerUnit() {
  String  tabgroup            = "Walker_Unit";
  Boolean enableAutosave      = true;
  String  id                  = getUuid(tabgroup);
  String  parentTabgroup_     = parentTabgroup;
  String  parentTabgroupUuid_ = getUuid(parentTabgroup_);
  Boolean userWasSet          = !username.equals("");


  parentTabgroup = null;

  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);

      String callback = "";
      callback += "; " + fun2str("executeOnEvent", new Object[]{tabgroup, "save"});
      callback += "; redrawGrid()";

      callback = fun2str(
          "updateGridCacheFromUuid",
          new Object[]{parentTabgroupUuid_, uuid, callback}
      );

      // Make a child-parent relationship if need be.
      if (
          newRecord &&
          !isNull(parentTabgroup_) &&
          !isNull(parentTabgroupUuid_)
      ) {
        String rel = "";
        rel += parentTabgroup_.replaceAll("_", " ");
        rel += " - ";
        rel += tabgroup.replaceAll("_", " ");
        saveEntitiesToHierRel(
          rel,
          parentTabgroupUuid_,
          uuid,
          "Parent Of",
          "Child Of",
          callback
        );
      } else {
        execute(callback);
      }

      // This fixes an interesting bug. Without this, if a user was not set
      // (by calling `setUser`) at the time `saveTabGroup` was first called, but
      // set by the time `onSave` was called, the tab group is saved correctly
      // the first time only.
      //
      // Adding this allows subsequent saves to succeed. Presumably it plays
      // some role in helping FAIMS associate the correct user with a record.
      if (!userWasSet) {
        saveTabGroup(tabgroup, callback);
      }

    }
    onError(message) {
      showToast(message);
    }
  };

  saveTabGroup(
      tabgroup,
      id,
      autoSaveGeo,
      autoSaveAttrs,
      saveCallback,
      enableAutosave
  );

  // Reset global variables
  autoSaveGeo   = null;
  autoSaveAttrs = null;
}

/************************* GRID - MISC EVENT HANDLERS *************************/
boolean DO_REDIRECT_TO_WALKER_UNIT = false;

inheritWalkerUnitFields() {
  setFieldValue(
    "Walker_Unit/Vars/Row_Number",
    String.valueOf(highlightedRow())
  );
  setFieldValue(
    "Walker_Unit/Vars/Walker_Number",
    String.valueOf(highlightedWalker())
  );
}

populateWalkerRadioGroup () {
  int    numberOfWalkers = numberOfWalkers();
  String selectedWalker  = String.valueOf(selectedWalker());
  String refWalker       = "Walker_Unit/Walker_Unit/Load_Walker";

  List walkerNumbers = new ArrayList();
  for (int i = 1; i <= numberOfWalkers; i++ ) {
    String s_i = String.valueOf(i);
    walkerNumbers.add(new NameValuePair(s_i, s_i));
  }

  populateRadioGroup(refWalker, walkerNumbers);
}

void onClickSurveyUnitAddNewWalkerUnit () {
  triggerSave();
  parentTabgroup   = "Survey_Unit";
  parentTabgroup__ = "Survey_Unit";
  loadOrMakeWalkerUnit();
}

boolean onClickSurveyUnitAddNewWalkerUnitCond() {
  if (
      NUM_RUNNING_GRID_UPDATES  .get() != 0 ||
      NUM_RUNNING_WALKER_UPDATES.get() != 0
  ) {
    showToast("Please try again in a moment");
    return false;
  }
  return true;
}

void onClickNextSurveyUnit() {
  cancelTabGroup("Walker_Unit", false);
  cancelTabGroup("Survey_Unit", false);

  DO_REDIRECT_TO_WALKER_UNIT = true;
  onClickControlAddNewSurveyUnit();
}

addOnEvent("Survey_Unit", "show", "triggerAutoSave()", PRECEDENCE_MID-1);

void saveWalkersToHierRel(String entity1, String entity2, String order, String callback) {
  if (isNull(entity1) || isNull(entity2)) return;

  SaveCallback execCallback = new SaveCallback() {
    onSaveAssociation(entity_id, rel_id) {
      if(!isNull(callback)) {
         execute(callback);
      }
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  };

  SaveCallback addMoreToRel = new SaveCallback() {
    onSaveAssociation(entity_id, rel_id) {
      addReln(entity2, rel_id, "Child Of", execCallback);
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  };

  SaveCallback addToRel = new SaveCallback() {
    onSave(rel_id, newRecord) {
      addReln(entity1, rel_id, "Parent Of", addMoreToRel);
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  };

  List attrs = createAttributeList();
  attrs.add(createEntityAttribute("Order", order, "", "", "1.0"));

  saveRel(null, "Survey Unit - Walker", null, attrs, addToRel);
}

void maybeRedirectToWalkerUnit() {
  if (DO_REDIRECT_TO_WALKER_UNIT) {
    DO_REDIRECT_TO_WALKER_UNIT = false;
    onClickSurveyUnitAddNewWalkerUnit();
  }
}

void enqueueWalkersToRelate() {
  WALKERS_TO_RELATE.addAll(getWalkerRels());
  dequeWalkersToRelate();
}

WALKERS_TO_RELATE     = new LinkedBlockingQueue();
MUTEX_DEQUEUE_WALKERS = new Semaphore(1);

void dequeWalkersToRelate() {
  Log.d("dequeWalkersToRelate", "Dequeuing");
  if (MUTEX_DEQUEUE_WALKERS.drainPermits() == 0) {
    return;
  }

  dequeWalkersToRelateRec();
}

void dequeWalkersToRelateRec() {
  Log.d("dequeWalkersToRelateRec", "Recing");
  if (WALKERS_TO_RELATE.size() == 0) {
    MUTEX_DEQUEUE_WALKERS.release();
    updateGridWalkers();
    populateEntityListsOfArchEnt("Walker");
    return;
  }

  List rel = WALKERS_TO_RELATE.take();
  String parentUuid = rel.get(0);
  String childUuid  = rel.get(1);
  String order      = rel.get(2);

  Log.d(
      "dequeWalkersToRelateRec",
      "parent, child, order = " + parentUuid + ", " + childUuid + ", " + order
  );

  saveWalkersToHierRel(
    parentUuid,
    childUuid,
    order,
    "dequeWalkersToRelateRec()"
  );
}

addOnEvent("Survey_Unit", "save", "maybeRedirectToWalkerUnit()");
addOnEvent("Survey_Unit", "firstsave", "enqueueWalkersToRelate()");

/*************************** GRID - EVENT BINDINGS ****************************/
addOnEvent("Walker_Unit/Walker_Unit/Zero_Row_And_Next_1", "click", "zeroRowAndNext()");
addOnEvent("Walker_Unit/Walker_Unit/Zero_Row_And_Next_2", "click", "zeroRowAndNext()");

addOnEvent("Walker_Unit/Walker_Unit/Next_Walker_Unit_1",    "click", "nextWalkerUnit()");
addOnEvent("Walker_Unit/Walker_Unit/Next_Walker_Unit_2",    "click", "nextWalkerUnit()");

addOnEvent("Walker_Unit/Walker_Unit/Delete_Row", "click",  "deleteRow()");

addOnEvent("Walker_Unit/Walker_Unit/Up",          "click",  "gridUp()");
addOnEvent("Walker_Unit/Walker_Unit/Down",        "click",  "gridDown()");
addOnEvent("Walker_Unit/Walker_Unit/Left",        "click",  "gridLeft()");
addOnEvent("Walker_Unit/Walker_Unit/Right",       "click",  "gridRight()");

addOnEvent("Walker_Unit",                        "show", "populateWalkerRadioGroup()");
addOnEvent("Walker_Unit",                        "create", "inheritWalkerUnitFields()");
addOnEvent("Walker_Unit",                        "create", "zeroIfBlank()");
addOnEvent("Walker_Unit",                        "leave",  "initHighlighted()");




addOnEvent("Survey_Unit",                 "create", "initGridCache()", PRECEDENCE_MID-1);
addOnEvent("Survey_Unit",                 "create", "updateGridWalkers()");

addOnEvent("Survey_Unit",                 "fetch",  "initGridCache()", PRECEDENCE_MID-1);
addOnEvent("Survey_Unit",                 "fetch",  "updateGridCache()");
addOnEvent("Survey_Unit",                 "fetch",  "updateGridWalkers()");

addOnEvent("Survey_Unit",                 "copy",   "initGridCache()", PRECEDENCE_MID-1);

addOnEvent("Walker",                      "save",   "updateGridWalkers()");
addOnEvent("Walker",                      "delete", "updateGridWalkers()");

addOnEvent("Walker_Unit/Walker_Unit/Next_Survey_Unit", "click", "onClickNextSurveyUnit()");



addOnEvent("Survey_Unit/Walker_Units/Add_New_Walker_Unit", "click", "onClickSurveyUnitAddNewWalkerUnit()");
addOnEventCond("Survey_Unit/Walker_Units/Add_New_Walker_Unit", "click", "onClickSurveyUnitAddNewWalkerUnitCond()");
addOnEvent("Walker_Unit/Walker_Unit/Load_Walker", "click",  "gridRandomAccessWalker()");
addOnEvent("Walker_Unit/Walker_Unit/Load",       "click",  "loadOrMakeWalkerUnit()");
