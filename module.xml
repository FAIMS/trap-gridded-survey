<?xml version="1.0" encoding="utf-8"?>
<!--@POSTPROC: ./postproc.sh -->
<module suppressWarnings="true">

<Login f="nodata">
  <Login f="noscroll">
    <User_Name t="list" f="user" l="Control"/>
  </Login>
</Login>

<Control f="nodata">
  <Main>
    <Add_New_Survey_Unit t="button" l="Survey_Unit"/>
    <Number_of_Rows    b="decimal"/>
    <Number_of_Walkers b="decimal"/>
  </Main>
  <search/>
  <Vars>
    <Highlighted_Row/>
    <Highlighted_Walker/>
    <Number_of_Rows/>
    <Number_of_Walkers/>
  </Vars>
</Control>

<Survey_Unit>
  <Survey_Unit f="noscroll">
    <Survey_Unit_ID f="id"/>
    <Add_New_Walker_Unit lc="Walker_Unit" t="button"/>
    <Walker_Units        ec="Walker_Unit"/>
  </Survey_Unit>
  <Vars>
    <Number_of_Rows/>
    <Number_of_Walkers/>
  </Vars>
</Survey_Unit>

<!--TODO: We need to zero out new records. *and save* (not do the ignore autosaving thing)-->
<!--      This will require additions to the DOM.-->

<!--TODO: Disable duplication of these-->
<Walker_Unit>
  <Walker_Unit>
    <!--TODO: Populate:-->
    <Survey_Unit_ID t="webview"/>
    <Grid           t="webview" f="nolabel"/>
    <!--D-Pad-->
    <cols>
      <Next_Row   t="button"/> <!--TODO-->
      <Up         t="button"/>
      <Add_Row    t="button"/>
    </cols>
    <cols>
      <Left       t="button"/>
      <Load       t="button"/>
      <Right      t="button"/>
    </cols>
    <cols>
      <group_bl   t="group"/>
      <Down       t="button"/>
      <Delete_Row t="button"/>
    </cols>
    <!--Buttons-->
    <N_A t="checkbox">
      <opts>
        <opt>N/A</opt>
      </opts>
    </N_A>
    <Null_Record t="button"/>
    <Zero_Row    t="button"/>
    <!--Main recording fields-->
    <cols>
      <Row_ID    b="decimal" f="id readonly"/>
      <Walker_ID b="decimal" f="id readonly"/>
    </cols>
    <cols>
      <col>
        <Ancient_Count b="decimal"/>
        <Modern_Count  b="decimal"/>
        <A_C_Count     b="decimal">
          A/C Count
        </A_C_Count>
        <Daub_Count b="decimal"/>
      </col>
      <col>
        <HM_Count     b="decimal"/>
        <Lithic_Count b="decimal"/>
        <Glass_Count  b="decimal"/>
        <Other_Count b="decimal"/>
      </col>
    </cols>
    <Notes/>
    <!--Buttons?-->
    <Chronology t="checkbox">
      <opts>
        <opt>Prehistoric</opt>
        <opt>Classical</opt>
        <opt>Medieval</opt>
        <opt>Ottoman</opt>
      </opts>
    </Chronology>
    <Fragment t="checkbox">
      <opts>
        <opt>Fragment</opt>
      </opts>
    </Fragment>
    <Wear t="checkbox">
      <opts>
        <opt>Wear</opt>
      </opts>
    </Wear>
  </Walker_Unit>
</Walker_Unit>

<logic><![CDATA[
  import java.util.concurrent.Semaphore;

  getGridHtml(
      int numberOfRows,   int numberOfWalkers,
      int highlightedRow, int highlightedWalker,
      int selectedRow,    int selectedWalker
  ) {
    // In a probably vain attempt to improve performance, this code is valid
    // HTML5.
    String html = "";

    html += "<!DOCTYPE html>";
    html += "<html>";
    html += "  <head>";
    html += "    <title>Grid</title>";
    html += "    <style>";
    html += "      table {";
    html += "        width: 100%;";
    html += "        border-collapse: separate;";
    html += "        border-spacing:  0px;";
    html += "      }";
    html += "      td {";
    html += "        padding: 3px;";
    html += "        border: 1px solid #000000;";
    html += "      }";
    html += "      td.highlighted {";
    html += "        padding: 0px;";
    html += "        border:  3px double #000000;";
    html += "        background-color: #CCCCCC;";
    html += "      }";
    html += "      td.selected {";
    html += "        background-color: #00AA00;";
    html += "        color:            #FFFFFF;";
    html += "      }";
    html += "    </style>";
    html += "  </head>";
    html += "  <table>";

    for (int i = numberOfRows; i >= 1; i--) {
      html += "    <tr>";
      for (int j = 1; j <= numberOfWalkers; j++) {
        Boolean isHighlighted = (i == highlightedRow && j == highlightedWalker);
        Boolean isSelected    = (i == selectedRow    && j == selectedWalker);

        String  cssClass = "";
        if (isHighlighted) cssClass += " highlighted";
        if (isSelected)    cssClass += " selected";

        String htmlRow = "";
        htmlRow += "      <td class=\"{cssClass}\">";
        htmlRow += "        Row {row}, Walker {walker}";
        htmlRow += "      </td>";
        htmlRow  = replaceFirst(htmlRow, "{cssClass}", cssClass);
        htmlRow  = replaceFirst(htmlRow, "{row}",      i);
        htmlRow  = replaceFirst(htmlRow, "{walker}",   j);

        html += htmlRow;
      }
      html += "    </tr>";
    }
    html += "  </table>";
    html += "</html>";

    return html;
  }

  getFieldValueAsInt(String ref) {
    String  val          = getFieldValue(ref);
    int valAsInteger = 0;

    try {
      valAsInteger = Integer.valueOf(val);
    } catch (Exception e) { ; }

    return valAsInteger.intValue();
  }

  clip(int x, int min, int max) {
    if (x > max) return max;
    if (x < min) return min;
    return x;
  }

  numberOfRows() {
    String ref = "Control/Vars/Number_of_Rows";
    return getFieldValueAsInt(ref);
  }

  // A mutex is required for `numberOfRows(int)` to handle users double-clicking
  // the 'Add Row' and 'Delete Row' buttons.
  MUTEX_WALKER_UNIT_ROWS = new Semaphore(1);

  /* It is assumed that this function is only ever called while "Walker_Unit" is
   * displayed.
   */
  numberOfRows(int val) {
    if (val < 1) val = 1; // `val` cannot be lower than 1.

    String refRowsControl    = "Control/Vars/Number_of_Rows";
    String refRowsSurveyUnit = "Survey_Unit/Vars/Number_of_Rows";
    String parentTabGroup    = getTabGroupRef(refRowsSurveyUnit);
    String parentUuid        = getUuid       (parentTabGroup);
    String parentArchEntType = getArchEntType(parentTabGroup);
    String attrName          = getAttributeName(refRowsSurveyUnit);
    String numberOfRows      = String.valueOf(val);
    List   geometry          = null;
    List   attributes        = createAttributeList();

    if (!getDisplayedTabGroup().equals("Walker_Unit"))
      return;

    if (!MUTEX_WALKER_UNIT_ROWS.tryAcquire()) {
      return;
    }

    // 1. If getPreviousTabGroup() == parentTabGroup, the user will visit it
    //    when they hit the back button. In this case, the value saved in the db
    //    must be made consistent with the one in the UI.
    if (getPreviousTabGroup().equals(parentTabGroup)) {
      setFieldValue(refRowsSurveyUnit, numberOfRows);
    }

    // 2. Also update the value in `refRowsControl`, which is used as a global
    //   variable.
    setFieldValue(refRowsControl, numberOfRows);

    // 3. Update 'Number of Rows' using saveArchEnt
    SaveCallback release = new SaveCallback() {
      onSave(uuid, newRecord) {
        MUTEX_WALKER_UNIT_ROWS.release();
      }
    };

    Object a = createEntityAttribute(attrName, null, null, numberOfRows, null);
    attributes.add(a);

    saveArchEnt(parentUuid, parentArchEntType, geometry, attributes, release);
  }

  addRow   () { numberOfRows(numberOfRows() + 1); redrawGrid(); }
  deleteRow() { numberOfRows(numberOfRows() - 1); redrawGrid(); }

  highlightedRow() {
    String ref = "Control/Vars/Highlighted_Row";
    int    val = getFieldValueAsInt(ref);

    return clip(val, 1, numberOfRows());
  }

  highlightedRow(int val) {
    val = clip(val, 1, numberOfRows());

    String ref = "Control/Vars/Highlighted_Row";
    setFieldValue(ref, String.valueOf(val));
  }

  selectedRow() {
    String ref = "Walker_Unit/Walker_Unit/Row_ID";
    return getFieldValueAsInt(ref);
  }

  numberOfWalkers() {
    String ref = "Control/Vars/Number_of_Walkers";
    return getFieldValueAsInt(ref);
  }

  highlightedWalker() {
    String ref = "Control/Vars/Highlighted_Walker";
    int    val = getFieldValueAsInt(ref);

    return clip(val, 1, numberOfWalkers());
  }

  highlightedWalker(int val) {
    val = clip(val, 1, numberOfWalkers());

    String ref = "Control/Vars/Highlighted_Walker";
    setFieldValue(ref, String.valueOf(val));
  }

  selectedWalker() {
    String ref = "Walker_Unit/Walker_Unit/Walker_ID";
    return getFieldValueAsInt(ref);
  }

  moveWalker(int delta) {
    highlightedWalker(highlightedWalker() + delta);
  }

  moveRow(int delta) {
    highlightedRow(highlightedRow() + delta);
  }

  initHighlighted() {
    highlightedRow   (1);
    highlightedWalker(1);
  }

  redrawGrid() {
    String ref  = "Walker_Unit/Walker_Unit/Grid";
    String html = getGridHtml(
        numberOfRows(),   numberOfWalkers(),
        highlightedRow(), highlightedWalker(),
        selectedRow(),    selectedWalker()
    );
    populateWebViewHtml(ref, html);
  }

  gridUp   () { moveRow   (+1); redrawGrid(); }
  gridDown () { moveRow   (-1); redrawGrid(); }
  gridLeft () { moveWalker(-1); redrawGrid(); }
  gridRight() { moveWalker(+1); redrawGrid(); }

  onCreateSurveyUnit() {
    copyFieldValue(
      "Control/Main/Number_of_Rows",
      "Control/Vars/Number_of_Rows",
      false
    );
    copyFieldValue(
      "Control/Main/Number_of_Walkers",
      "Control/Vars/Number_of_Walkers",
      false
    );

    copyFieldValue(
      "Control/Main/Number_of_Rows",
      "Survey_Unit/Vars/Number_of_Rows",
      false
    );
    copyFieldValue(
      "Control/Main/Number_of_Walkers",
      "Survey_Unit/Vars/Number_of_Walkers",
      false
    );
  }

  onCreateWalkerUnit() {
    setFieldValue(
      "Walker_Unit/Walker_Unit/Row_ID",
      String.valueOf(highlightedRow())
    );
    setFieldValue(
      "Walker_Unit/Walker_Unit/Walker_ID",
      String.valueOf(highlightedWalker())
    );
    redrawGrid();
    zeroIfBlank();
  }

  onLoadWalkerUnit() {
    String tabgroup   = "Walker_Unit";
    String childUuid  = getUuid(tabgroup);

    String q = "";
    q += " SELECT attributename, measure";
    q += "   FROM latestnondeletedaentvalue";
    q += "   JOIN attributekey USING (attributeid)";
    q += "   JOIN parentchild ON (uuid = parentuuid)";
    q += "  WHERE attributename IN ('Number of Rows', 'Number of Walkers')";
    q += "    AND childuuid = '{childUuid}'";
    q  = replaceFirst(q, "{childUuid}", childUuid);

    FetchCallback updateGridDimsVars = new FetchCallback() {
      onFetch(result) {
        updateGridDimsVars(result);
        redrawGrid();
      }
    };

    fetchAll(q, updateGridDimsVars);
    updateWalkerUnitParentVars(childUuid);
  }

  updateGridDimsVars(result) {
    String refRows    = "Control/Vars/Number_of_Rows";
    String refWalkers = "Control/Vars/Number_of_Walkers";

    String attrNameRows    = getAttributeName(refRows);
    String attrNameWalkers = getAttributeName(refWalkers);

    if (result == null) return;
    for (row : result) {
      String attrName = row.get(0);
      String attrVal  = row.get(1);

      if (attrName.equals(attrNameRows   )) setFieldValue(refRows,    attrVal);
      if (attrName.equals(attrNameWalkers)) setFieldValue(refWalkers, attrVal);
    }
  }

  updateWalkerUnitParentVars(String childUuid) {
    updateWalkerUnitParentVars(childUuid, "");
  }

  updateWalkerUnitParentVars(String childUuid, String callback) {
    String q = "";
    q += " SELECT parentuuid";
    q += "   FROM parentchild";
    q += "  WHERE childuuid='{childUuid}'";
    q += "    AND parentparticipatesverb='Parent Of'";
    q  = replaceFirst(q, "{childUuid}", childUuid);

    FetchCallback updateWalkerUnitParentVars = new FetchCallback() {
      onFetch(result) {
        parentTabgroup   = "Survey_Unit";
        parentTabgroup__ = "Survey_Unit";

        if (result        == null) { execute(callback); return; }
        if (result.size() == 0   ) { execute(callback); return; }

        String parentUuid = result.get(0).get(0);
        setUuid(parentTabgroup, parentUuid);

        execute(callback);
      }
    };

    fetchAll(q, updateWalkerUnitParentVars);
  }

  // TODO: Loading *might* be broken; The list of child entities in the parent
  // doesn't get refreshed after making a new Walker Unit via a loaded one.
  // TODO: Loading might cause other child entities to be saved with incorrect
  // relationships

  // A mutex is required for `loadWalkerUnit` to handle users double-clicking
  // the load button.
  MUTEX_WALKER_UNIT_LOAD = new Semaphore(1);

  /* This function is intended to be called from the "Walker_Unit" tab group. It
   * is not intended to be called from the parent of the "Walker_Unit" tab
   * group.
   */
  loadWalkerUnit() {
    String tabgroup   = "Walker_Unit";
    String childUuid  = getUuid(tabgroup);
    String parentUuid = getUuid(parentTabgroup__);
    String rowId      = String.valueOf(highlightedRow   ());
    String walkerId   = String.valueOf(highlightedWalker());

    // The selected walker unit is already loaded
    if (
        getDisplayedTabGroup().equals(tabgroup) &&
        highlightedRow   () == selectedRow   () &&
        highlightedWalker() == selectedWalker()
    ) {
      return;
    }

    // We are still waiting for a previous `loadWalkerUnit` to complete
    if (!MUTEX_WALKER_UNIT_LOAD.tryAcquire()) {
      return;
    }

    String q = "";
    q += " SELECT uuid";
    q += "   FROM latestnondeletedaentvalue";
    q += "   JOIN attributekey using (attributeid)";
    q += "  WHERE measure = '{walkerId}'";
    q += "    AND attributename = 'Walker ID'";
    q += "    AND uuid IN (";
    q += "                 SELECT uuid";
    q += "                   FROM latestnondeletedaentvalue";
    q += "                   JOIN attributekey USING (attributeid)";
    q += "                   JOIN parentchild ON (uuid = childuuid)";
    q += "                  WHERE measure = '{rowId}'";
    q += "                    AND attributename = 'Row ID'";
    q += "                    AND parentuuid = '{parentUuid}'";
    q += "        );";
    q  = replaceFirst(q, "{rowId}",      rowId);
    q  = replaceFirst(q, "{walkerId}",   walkerId);
    q  = replaceFirst(q, "{parentUuid}", parentUuid);

    FetchCallback loadWalkerUnit = new FetchCallback() {
      onFetch(result) {
        // 1. An "blur" event will not be triggered by the following steps. We
        //    must zero-out all blank fields manually.
        zeroIfBlank();

        // 2. Leaving "Walker_Unit" calls `initHighlighted`, so we must store
        //    (and later restore) the highlighted cell.
        int highlightedRow    = highlightedRow   ();
        int highlightedWalker = highlightedWalker();

        // 3. Leave "Walker_Unit".
        if (getDisplayedTabGroup().equals(tabgroup))
          cancelTabGroup(tabgroup, false);

        // 4. Restore the highlighted cell.
        highlightedRow   (highlightedRow   );
        highlightedWalker(highlightedWalker);

        // 5. Re-enter "Walker_Unit" with the desired record loaded.
        if (result == null || result.size() == 0) {
          parentTabgroup = "Survey_Unit";
          newWalkerUnit();
        } else {
          String uuid = result.get(0).get(0);
          loadWalkerUnitFrom(uuid);
        }

        // 6. The `loadWalkerUnit` is effectively finished.
        MUTEX_WALKER_UNIT_LOAD.release();
      }
    };

    fetchAll(q, loadWalkerUnit);
  }

  // Overrides autogen's definition
  onClickSurveyUnitAddNewWalkerUnit () {
    String tabgroup = "Survey_Unit";
    if (isNull(getUuid(tabgroup))){
      showToast("{You_must_save_this_tabgroup_first}");
      return;
    }
    parentTabgroup   = tabgroup;
    parentTabgroup__ = tabgroup;
    loadWalkerUnit();
  }

  getZeroableRefs() {
    List   elemNames = new ArrayList(); // names of zeroable elements
    List   refs      = new ArrayList(); // references of zeroable elements
    String fmtRef    = "Walker_Unit/Walker_Unit/%s";

    // 1. Write the element names
    elemNames.add("Ancient_Count");
    elemNames.add("Modern_Count");
    elemNames.add("A_C_Count");
    elemNames.add("Daub_Count");
    elemNames.add("HM_Count");
    elemNames.add("Lithic_Count");
    elemNames.add("Glass_Count");
    elemNames.add("Other_Count");

    // 2. Format the element names into refs
    for (e : elemNames) {
      String ref = replaceFirst(fmtRef, e);
      refs.add(ref);
    }

    return refs;
  }

  zeroIfBlank() {
    for (ref : getZeroableRefs()) {
      zeroIfBlank(ref);
    }
  }

  zeroIfBlank(String ref) {
    String blank = "";
    String zero  = "0";
    String val   = getFieldValue(ref);
    if (blank.equals(val)) {
      setFieldValue(ref, zero);
    }
  }

  blankIfZero(String ref) {
    String blank = "";
    String zero  = "0";
    String val   = getFieldValue(ref);
    if (zero.equals(val)) {
      setFieldValue(ref, blank);
    }
  }

  for (ref : getZeroableRefs()) {
    String focus = "blankIfZero(\"%s\")"; focus = replaceFirst(focus, ref);
    String blur  = "zeroIfBlank(\"%s\")"; blur  = replaceFirst(blur,  ref);

    addOnEvent(ref, "focus", focus);
    addOnEvent(ref, "blur",  blur );
  }

  addOnEvent("Walker_Unit/Walker_Unit/Add_Row",    "click", "addRow         ()");
  addOnEvent("Walker_Unit/Walker_Unit/Delete_Row", "click", "deleteRow      ()");

  addOnEvent("Walker_Unit/Walker_Unit/Up",         "click", "gridUp         ()");
  addOnEvent("Walker_Unit/Walker_Unit/Down",       "click", "gridDown       ()");
  addOnEvent("Walker_Unit/Walker_Unit/Left",       "click", "gridLeft       ()");
  addOnEvent("Walker_Unit/Walker_Unit/Right",      "click", "gridRight      ()");
  addOnEvent("Walker_Unit/Walker_Unit/Load",       "click", "loadWalkerUnit ()");
  addOnEvent("Walker_Unit",                        "leave", "initHighlighted()");

  persistOverSessions("Control/Main/Number_of_Rows");
  persistOverSessions("Control/Main/Number_of_Walkers");
]]></logic>

</module>
