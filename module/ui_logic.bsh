import android.util.Log;

Object dialog;          // Used to help coordinate the display of a "busy..." dialog
String parentTabgroup;  // Used to allow entities to be saved as children
String parentTabgroup__;// Used to allow entities to be saved as children
String redirectTab;     // makes newTab work as expected
String username = "";
String userid   = "";

setFileSyncEnabled(true);
setSyncDelay(5.0f);
setSyncEnabled(true);
setSyncMaxInterval(600.0f);
setSyncMinInterval(5.0f);

/*********************** REGEX-FREE STRING REPLACEMENT ************************/
replaceFirst(haystack, needle, replacement) {
  i = haystack.indexOf(needle);
  if (i == -1)           return haystack;
  if (needle.equals("")) return haystack;
  pre  = haystack.substring(0, i                                   );
  post = haystack.substring(   i+needle.length(), haystack.length());
  return pre + replacement + post;
}

replaceFirst(haystack, replacement) {
  return replaceFirst(haystack, "%s", replacement);
}

/******************************* LOCALSETTINGS ********************************/
makeLocalID(){
  fetchOne("CREATE TABLE IF NOT EXISTS localSettings (key text primary key, value text);", null);
  fetchOne("DROP VIEW IF EXISTS parentchild;", null);
  fetchOne("CREATE VIEW parentchild AS "+
           "SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename "+
           "  FROM (SELECT uuid, participatesverb, aenttypename, relationshipid"+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) parent "+
           "  JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
           "          FROM latestnondeletedaentreln "+
           "          JOIN relationship USING (relationshipid) "+
           "          JOIN latestnondeletedarchent USING (uuid) "+
           "          JOIN aenttype USING (aenttypeid)) child "+
           "    ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid);", null);
}
makeLocalID();

insertIntoLocalSettings(String ref) {
  String val = getFieldValue(ref);
  insertIntoLocalSettings(ref, val);
}

insertIntoLocalSettings(String key, String val) {
  fetchOne("REPLACE INTO localSettings(key, value) VALUES('" + key + "', '" + val + "');");
}

insertIntoLocalSettings(String key, Integer val) {
  insertIntoLocalSettings(key, Integer.toString(val));
}

insertIntoLocalSettingsOnBlur(String ref) {
  String val = getFieldValue(ref);

  String focusCallback = "";
  String blurCallback  = "";
  blurCallback += "insertIntoLocalSettings(\"{key}\")";
  blurCallback  = replaceFirst(blurCallback, "{key}", ref);

  onFocus(ref, focusCallback, blurCallback);
}

setFieldValueFromLocalSettings(String key, String ref) {
  String q = "SELECT value FROM localSettings WHERE key = '" + key + "';";
  fetchOne(q, new FetchCallback() {
    onFetch(result) {
      if (!isNull(result)) {
        setFieldValue(ref, result.get(0));
      }
    }
  });
}

setFieldValueFromLocalSettingsOnShow(String ref) {
  String refTabGroup = getTabGroupRef(ref);

  String event = "";
  event += "setFieldValueFromLocalSettings(\"{key}\", \"{val}\")";
  event  = replaceFirst(event, "{key}", ref);
  event  = replaceFirst(event, "{val}", ref);

  addOnEvent(refTabGroup, "show", event);
}

/* Causes the value of the field given by `ref` to be saved each time it is
 * modified (on blur). The value of the field is restored when the tab group
 * containing the field is displayed.
 *
 * This function depends on `addOnEvent`. Therefore this function must be called
 * after `addOnEvent` is defined, but before `bindOnEvents` is called. This will
 * be so if the call is made in the autogenerator's `logic` tags.
 */
persistOverSessions(String ref) {
  setFieldValueFromLocalSettingsOnShow(ref);
  insertIntoLocalSettingsOnBlur(ref);
}

/**************************** FIELD COPYING HELPER ****************************/
/* Provides an easy way to copy field values, even between vocabs.            */
/******************************************************************************/
copyFieldValue(src, dst) {
  Boolean doFindVocabId = true;
  copyFieldValue(src, dst, doFindVocabId);
}

/* `src`           The ref of the source field.
 * `dst`           The ref of the destination field.
 * `doFindVocabId` If this is true, and the properties/attributes of `src` and
 *                 `dst` are different, `copyFieldValue` treats `src` and `dst`
 *                 as if they were menus. Therefore, to copy the value seen by
 *                 the user (i.e. the vocabName of `src`), a database query is
 *                 performed. The query determines the which vocabId of `dst`
 *                 will make it display the same vocabName as `src`.
 *
 *                 If `doFindVocabId` is false, the value returned by
 *                 `getFieldValue` is copied, without any database accesses.
 */
copyFieldValue(src, dst, doFindVocabId) {
  String vocabIdSrc   = getFieldValue(src);
  String vocabNameSrc = getFieldValue(src, true);

  String attrNameSrc = getAttributeName(src);
  String attrNameDst = getAttributeName(dst);

  if (attrNameSrc.equals(attrNameDst) || !doFindVocabId) {
    setFieldValue(dst, vocabIdSrc);
    return;
  }

  String q = "";
  q += "    SELECT vocabid";
  q += "      FROM vocabulary";
  q += " LEFT JOIN attributekey";
  q += "     USING (attributeid)";
  q += "     WHERE attributename = '{attrNameDst}'";
  q += "       AND vocabname     = '{vocabNameSrc}'";
  q  = replaceFirst(q, "{attrNameDst}",  attrNameDst);
  q  = replaceFirst(q, "{vocabNameSrc}", vocabNameSrc);


  FetchCallback populate = new FetchCallback() {
    onFetch(result) {
      if (result == null) {
        // Fall back to dumb field copying
        copyFieldValue(src, dst, false);
      }

      String vocabIdDst = result.get(0);
      setFieldValue(dst, vocabIdDst);
    }
  };

  fetchOne(q, populate);
}

newTab(String tab, Boolean resolveTabGroups) {
  if (!resolveTabGroups) {
    return newTab(tab);
  }

  tab = tab.replaceAll("/$", "");
  tab = tab.replaceAll("^/", "");

  path = tab.split("/");
  switch (path.length) {
    case 0:
      break;
    case 1:
      newTabGroup(path[0]);
      break;
    case 2:
      String tabgroupString = path[0];
      String tabString      = path[0] + "/" + path[1];

      redirectTab = tabString;
      String onShowTabgroup = "if (!isNull(redirectTab)) { newTab(redirectTab); redirectTab = \"\"; }";
      addOnEvent(tabgroupString, "show", onShowTabgroup);

      newTabGroup(tabgroupString);
      newTab(tabString);
      break;
    default:
  }
}

/******************************************************************************/
/*                           DOCUMENT OBJECT MODEL                            */
/******************************************************************************/
String PREVIOUSLY_DISPLAYED_TAB_GROUP = "";
String CURRENTLY_DISPLAYED_TAB_GROUP  = "";

getTabGroups() {
  List tabGroups = new ArrayList();
  tabGroups.add("Login");
  tabGroups.add("Control");
  tabGroups.add("Survey_Unit");
  tabGroups.add("Walker_Unit");

  return tabGroups;
}

updateDisplayedTabGroup(String tabGroup) {
  PREVIOUSLY_DISPLAYED_TAB_GROUP = CURRENTLY_DISPLAYED_TAB_GROUP;
  CURRENTLY_DISPLAYED_TAB_GROUP  = tabGroup;
}

getPreviousTabGroup() {
  return getPreviouslyDisplayedTabGroup();
}

getPreviouslyDisplayedTabGroup() {
  return PREVIOUSLY_DISPLAYED_TAB_GROUP;
}

getDisplayedTabGroup() {
  return CURRENTLY_DISPLAYED_TAB_GROUP;
}

isDisplayed(String ref) {
  return getDisplayedTabGroup().equals(ref);
}

getTabGroupRef(String fullRef) {
  Boolean lastPartOnly = false;
  return getTabGroupRef(fullRef, lastPartOnly);
}

getTabGroupRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 1) return null;
  return parts[0];
}

getTabRef(String fullRef) {
  Boolean lastPartOnly = false;
  return getTabRef(fullRef, lastPartOnly);
}

getTabRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 2) return null;
  if (lastPartOnly) return                  parts[1];
  else              return parts[0] + "/" + parts[1];
}

getLastRefPart(String ref) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");
  return parts[parts.length-1];
}

getGuiElementRef(String fullRef) {
  Boolean lastPartOnly = true;
  return getGuiElementRef(fullRef, lastPartOnly);
}

getGuiElementRef(String fullRef, Boolean lastPartOnly) {
  if (isNull(fullRef)) {
    return null;
  }

  String[] parts = fullRef.split("/");

  if (parts.length < 3) return null;
  if (lastPartOnly) return parts[2];
  else              return fullRef;
}

getArch16nKey(String ref) {
  String lastRefPart = getLastRefPart(ref);

  if (isNull(lastRefPart)) return null;
  else                     return "{" + lastRefPart + "}";
}

guessArch16nVal(String ref) {
  String arch16nKey = getArch16nKey(ref);

  if (isNull(getArch16nKey)) return "";
  arch16nKey = arch16nKey.replaceAll("_", " ");
  arch16nKey = arch16nKey.replaceAll("^\\{", "");
  arch16nKey = arch16nKey.replaceAll("\\}$", "");
  return arch16nKey;
}

getAttributeName(String ref) {
  String guiElementRef = getGuiElementRef(ref);
  if (isNull(guiElementRef)) {
    return null;
  }

  String attributeName = guiElementRef.replaceAll("_", " ");
  return attributeName;
}

getArchEntType(String ref) {
  String tabGroupRef = getTabGroupRef(ref);
  if (isNull(tabGroupRef)) {
    return null;
  }

  String archEntType = tabGroupRef.replaceAll("_", " ");
  return archEntType;
}

/******************************************************************************/
/*                            BINDING ACCUMULATOR                             */
/*                                                                            */
/* The binding accumulator allows onEvent bindings for the same element to    */
/* accumulate over multiple onEvent calls instead of having later calls       */
/* override earlier ones.                                                     */
/*                                                                            */
/* It also adds support for a several additional events:                      */
/*   - "blur" --- This is merely an interface to make code for adding "blur"  */
/*         events more consistent.                                            */
/*   - "create" --- Triggered after a record is first created.                */
/*   - "fetch" --- Triggered after a record is fetched and displayed in a     */
/*         given tab group.                                                   */
/*   - "focus" --- This is merely an interface to make code for adding        */
/*         "focus" events more consistent.                                    */
/*   - "leave" --- Triggered after a given tab group is navigated away        */
/*         from. Note that this event cannot be triggered when the FAIMS app  */
/*         is exited.                                                         */
/******************************************************************************/
String SEP = Character.toString ((char) 0); // Beanshell won't let me write "\0"
Map    EVENTS        = new HashMap(); // (ref, event type) -> callback statement
Set    CUSTOM_EVENTS = new HashSet(); // Events not handled by `onEvent`
CUSTOM_EVENTS.add("blur");
CUSTOM_EVENTS.add("create");
CUSTOM_EVENTS.add("fetch");
CUSTOM_EVENTS.add("focus");
CUSTOM_EVENTS.add("leave");

getKey(String ref, String event) {
  return ref + SEP + event;
}

/* Returns the set of statements bound to an element at `ref` and occuring on
 * `event`.
 */
getStatements(String ref, String event) {
  String    key = getKey(ref, event);
  ArrayList val = (ArrayList) EVENTS.get(key);

  if (val == null) return new ArrayList();
  else             return val;
}

addStatement(String ref, String event, String statement) {
  // In the case that a statement already exists for a given (`ref`, `event`)
  // pair, writing `val.add(statement);` will be enough to add the extra
  // statement. This is because `getStatements` returns a reference to a list.
  // In the case just described, the list is stored in the `EVENTS` map.
  // However, sometimes `getStatements` returns empty lists which are not stored
  // in that map. In this case, calling `EVENTS.put` is required.

  String    key = getKey(ref, event);
  ArrayList val = getStatements(ref, event);
  val.add(statement);
  EVENTS.put(key, val);
}

getStatementsString(String ref, String event) {
  ArrayList stmts = getStatements(ref, event);
  String stmtsStr = "";
  for (String s : stmts) {
    stmtsStr += s;
    stmtsStr += "; ";
  }
  return stmtsStr;
}

delOnEvent(String ref, String event, String statement) {
  while(getStatements(ref, event).remove(statement));
}

addOnEvent(String ref, String event, String statement) {
  // Calling `delOnEvent()` first ensures statement occurs once in the list, at
  // the end.
  delOnEvent  (ref, event, statement);
  addStatement(ref, event, statement);
}

bindOnEvent(String ref, String event) {
  String stmtsStr     = getStatementsString(ref, event);
  String focusStmtStr = getStatementsString(ref, "focus");
  String blurStmtStr  = getStatementsString(ref, "blur" );

  if (!CUSTOM_EVENTS.contains(event)) {
    onEvent(ref, event, stmtsStr);
  } else if (event.equals("focus")) {
    onFocus(ref, focusStmtStr, blurStmtStr);
  } else if (event.equals("blur" )) {
    onFocus(ref, focusStmtStr, blurStmtStr);
  }
}

bindOnEvents() {
  for (String key : EVENTS.keySet()) {
    refevent = key.split(SEP);
    ref   = refevent[0];
    event = refevent[1];
    bindOnEvent(ref, event);
  }
}

onLeaveTabGroup() {
  onLeaveTabGroup(getPreviouslyDisplayedTabGroup());
}

/* Execute the "leave" event for the tab group at `ref` if a callback for it
 * exists.
 */
onLeaveTabGroup(String ref) {
  String event    = "leave";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

/* Establishes `onEvent` bindings necessary to make the "leave" event work. The
 * "leave" event is really triggered upon "show" of another tab.
 */
for (tg : getTabGroups()) {
  String ref      = tg;
  String event    = "show";
  String callback;

  // Update (previously) displayed tab group
  callback = "updateDisplayedTabGroup(\"%s\")";
  callback = replaceFirst(callback, tg);
  addOnEvent(tg, event, callback);

  // Trigger on leave tab group event
  callback = "onLeaveTabGroup()";
  addOnEvent(tg, event, callback);
}

/******************************************************************************/
/*                           DROPDOWN VALUE GETTER                            */
/*                                                                            */
/* For consistency with `getListItemValue()`.                                 */
/******************************************************************************/
String dropdownItemValue = null;

getDropdownItemValue() {
  return dropdownItemValue;
}


/******************************************************************************/
/*                             MENU VALUE GETTER                              */
/*                                                                            */
/* Provides simple ways of getting a menu's vocabname as opposed to the       */
/* default, which is the vocabid.                                             */
/******************************************************************************/
// Map from vocabid to vocabname. Populated by `fetchMenuValues()`.
Map MENU_VALUES = null;

/*
 * Initialises `MENU_VALUES` with the (vocabid -> vocabname) mapping of every
 * menu.
 */
fetchMenuValues() {
  MENU_VALUES = new HashMap();

  String q = "";
  q += " SELECT vocabid, vocabname";
  q += " FROM   vocabulary";

  populateHashMap = new FetchCallback() {
    onFetch(result) {
      for (row : result) {
        vocabId   = row.get(0);
        vocabName = row.get(1);
        MENU_VALUES.put(vocabId, vocabName);
      }
    }
  };

  fetchAll(q, populateHashMap);
}

fetchMenuValues();

/* Returns a menu's vocabname, instead of the (counter-intuitive) vocabid.
 */
getFieldValue(String ref, Boolean doConvertVocabIds) {
  if (!doConvertVocabIds) {
    return getFieldValue(ref);
  }

  String val       = getFieldValue(ref);
  String vocabName = MENU_VALUES.get(val);

  if (val       == null) return "";
  if (vocabName == null) return "";
  return vocabName;
}

/* Shorthand for writing getFieldValue(ref, true). This function's use is
 * discouraged in favour of writing `getFieldValue(ref, true)`.
 */
getMenuValue(String ref) {
  return getFieldValue(ref, true);
}

/******************************************************************************/
/*                                 ACTION BAR                                 */
/******************************************************************************/
addActionBarItem("clean_synced_files", new ActionButtonCallback() {
  actionOnLabel() {
    "{Clean_Synced_Files}";
  }
  actionOn() {
    cleanSyncedFiles();
  }
});

addActionBarItem("sync", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Sync}";
  }
  actionOn() {
    setSyncEnabled(false);
    setFileSyncEnabled(false);
    showToast("{Sync_Disabled}");
  }
  isActionOff() {
    isSyncEnabled();
  }
  actionOffLabel() {
    "{Enable_Sync}";
  }
  actionOff() {
    setSyncEnabled(true);
    setFileSyncEnabled(true);
    showToast("{Sync_Enabled}");
  }
});

addActionBarItem("internal_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_Internal_GPS}";
  }
  actionOn() {
    stopGPS();
    showToast("{Internal_GPS_Disabled}");
    updateGPSDiagnostics();
  }
  isActionOff() {
    isInternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_Internal_GPS}";
  }
  actionOff() {
    if(isExternalGPSOn()) {
      stopGPS();
    }
    startInternalGPS();
    showToast("{Internal_GPS_Enabled}");
    updateGPSDiagnostics();
  }
});

addActionBarItem("external_gps", new ToggleActionButtonCallback() {
  actionOnLabel() {
    "{Disable_External_GPS}";
  }
  actionOn() {
    stopGPS();
    if (isBluetoothConnected()) {
      showToast("{External_GPS_Disabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
    }
    updateGPSDiagnostics();
  }
  isActionOff() {
    isExternalGPSOn();
  }
  actionOffLabel() {
    "{Enable_External_GPS}";
  }
  actionOff() {
    if(isInternalGPSOn()) {
      stopGPS();
    }
    startExternalGPS();
    if(isBluetoothConnected()) {
      showToast("{External_GPS_Enabled}");
    } else {
      showToast("{Please_Enable_Bluetooth}");
      this.actionOn();
    }
    updateGPSDiagnostics();
  }
});


/******************************************************************************/
/*                                    GPS                                     */
/******************************************************************************/

updateGPSDiagnostics() {
  String diagnosticsRef = "";
  if (diagnosticsRef.equals("")) {
    return;
  }

  String status         = "";
  String previousStatus = getFieldValue(diagnosticsRef);
  String notInitialised = "{GPS_is_not_initialised}";

  // Check if GPS is initialised or was previously initialised.
  if (!isExternalGPSOn() && !isInternalGPSOn()) {
    if (!isNull(previousStatus) && !previousStatus.equals(notInitialised)) { // previous gps status is some last valid coordinate.
      // This is hackish. Arch16n substitution happens only at display-time, but the following if clause requires substitution to have happened at run-time
      String error = "";
      error = "{GPS_is_no_longer_initialised}. {Previous_status}:";
      setFieldValue(diagnosticsRef, error);   // Arch16n entry is substituted after this
      error = getFieldValue(diagnosticsRef);

      // check that error message wasn't previously appended to the previous status message.
      if (previousStatus.length()    >= error.length() &&
          previousStatus.subSequence(0, error.length()).equals(error)) {
        status = previousStatus;
      } else {
        status = error + "\n" + previousStatus;
      }
    } else {
      status = notInitialised;
    }
  } else {
    status += "{Internal_GPS}: ";
    if (isInternalGPSOn())
    {
      status += "{on}";
    } else {
      status += "{off}";
    }
    status += "\nExternal GPS: ";
    if (isExternalGPSOn())
    {
      if (isBluetoothConnected()) {
        status += "{on_and_bluetooth_connected}";
      } else {
        status += "{on_and_bluetooth_disconnected}";
      }
    } else {
      status += "{off}";
    }
    Object position = getGPSPosition();
    if (position != null) {
      Object projPosition = getGPSPositionProjected();
      status += "\n{Latitude}: " + position.getLatitude();
      status += "   {Longitude}: " + position.getLongitude();
      status += "\n{Northing}: " + projPosition.getLatitude();
      status += "   {Easting}: " + projPosition.getLongitude();
      status += "\n{Accuracy}: " + getGPSEstimatedAccuracy();
    } else {
      status += "\n{Position}: {no_GPS_position_could_be_found}";
    }
  }
  setFieldValue(diagnosticsRef, status);
}

/******************************************************************************/
/*                                 USER LOGIN                                 */
/******************************************************************************/

String userMenuPath = "Login/Login/User_Name";

populateListForUsers(){
  String getNonDeletedUsersQuery = "SELECT userid, fname || ' ' || lname "+
                                   "  FROM user "+
                                   " WHERE userdeleted is null;";

  fetchAll(getNonDeletedUsersQuery, new FetchCallback() {
    onFetch(result) {
      populateList(userMenuPath, result);
    }
  });
}

selectUser () {
  String userVocabId  = getListItemValue();
  String userQ        = "SELECT userid,fname,lname,email FROM user " +
                        "WHERE  userid='" + userVocabId + "';";
  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      user = new User(
            result.get(0),
            result.get(1),
            result.get(2),
            result.get(3)
      );
      setUser(user);
      username = result.get(1) + " " + result.get(2);
      userid   = result.get(0);
    }
  };

  fetchOne(userQ, callback);
}

addOnEvent(userMenuPath, "show",  "populateListForUsers()");
addOnEvent(userMenuPath, "click", "selectUser()");


/******************************************************************************/
/*                              MENU POPULATION                               */
/******************************************************************************/
/** Fetches the contents of a specifed vocabulary and stores it in the given list. **/
fetchVocab(String vocabName, List storageList) {
  fetchVocab(vocabName, storageList, null);
}
fetchVocab(String vocabName, List storageList, String callbackFunction) {
  fetchAll("select vocabid, vocabname from vocabulary left join attributekey using (attributeid) where attributename = '" + vocabName + "';", new FetchCallback() {
    onFetch(result) {
      storageList.addAll(result);
      Log.d("fetchVocab()", "Fetched vocabulary \"" + vocabname + "\" contents: " + result.toString());
      if (callbackFunction != null && !isNull(callbackFunction)) {
        execute(callbackFunction);
      }
    }
  });
}

/** Wrapper for to make a vocab without an exlusion list **/
makeVocab(String type, String path, String attrib) {
  makeVocab(type, path, attrib, null);
}

/** Vocab Population **/
/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (PictureGallery, HierarchicalPictureGallery, CheckBoxGroup, DropDown, HierarchicalDropDown, RadioGroup or List). */
makeVocab(String type, String path, String attrib, List vocabExclusions) {
    makeVocab(type, path, attrib, vocabExclusions, null);
}

/* Populates the path specified vocabulary from the database based on the given attribute name, where type 
is the type of the vocab to populate (PictureGallery, HierarchicalPictureGallery, CheckBoxGroup, DropDown, HierarchicalDropDown, RadioGroup or List). */
makeVocab(String type, String path, String attrib, List vocabExclusions, String callbackFunction){
  if (isNull(type) || isNull(path) || isNull(attrib)) {
    Log.e("makeVocab()", "Can't make populate a vocab when the given type, path or attribute is Null");
    return;
  }

  if (type.equals("PictureGallery")) {
    String pictureGalleryQuery = "SELECT vocabid, vocabname, pictureurl "+
                                 "  FROM vocabulary "+
                                 "  LEFT OUTER JOIN attributekey USING (attributeid) "+
                                 " WHERE attributename = '" + attrib + "' "+
                                 " ORDER BY  vocabcountorder;";
    fetchAll(pictureGalleryQuery, new FetchCallback() {
      onFetch(pictures) {
        populatePictureGallery(path, pictures);
        if (callbackFunction != null && !isNull(callbackFunction)) {
          execute(callbackFunction);
        }
      }
    });
    return;
  }

  if (type.equals("HierarchicalPictureGallery")) {
    populateHierarchicalPictureGallery(path, attrib);
    if (callbackFunction != null && !isNull(callbackFunction)) {
      execute(callbackFunction);
    }
    return;
  }

  if (type.equals("HierarchicalDropDown")) {
    // populateHierarchicalDropDown(path, attrib);
    populateHierarchicalDropDown(path, attrib, true);
    if (callbackFunction != null && !isNull(callbackFunction)) {
      execute(callbackFunction);
    }
    return;
  }

  String getAttributeVocabQuery = "SELECT vocabid, vocabname "+
                                  "  FROM vocabulary "+
                                  "  JOIN attributekey USING (attributeid) "+
                                  " WHERE attributename = '" + attrib + "' "+
                                  " ORDER BY vocabcountorder;";
  fetchAll(getAttributeVocabQuery,
    new FetchCallback() {
      onFetch(result) {
        // print("makeVocab() result: " + result);
        if (result!=null && result.size()>0 && vocabExclusions!=null && vocabExclusions.size()>0) {
          List filteredVocab = new ArrayList();
          for(item : result) {
            if (vocabExclusions.contains(item.get(1))) {
              Log.d("makeVocab()", "removing vocab exclusion: " + item.get(1));
            } else {
              filteredVocab.add(item);
            }
          }
          result=filteredVocab;
        }
        Boolean hasNull =
                vocabExclusions == null
            || !vocabExclusions.contains("")
            && !vocabExclusions.contains(null);
        // print("makeVocab() filtered result: " + result);
        if(type.equals("CheckBoxGroup")) {
          populateCheckBoxGroup(path, result);
        } else if(type.equals("DropDown")) {
          // populateDropDown(path, result);
          populateDropDown(path, result, hasNull);
        } else if(type.equals("RadioGroup")) {
          populateRadioGroup(path, result);
        } else if(type.equals("List")) {
          populateList(path, result);
        }
        if (callbackFunction != null && !isNull(callbackFunction)) {
          execute(callbackFunction);
        }
      }
    });
}
makeVocab("CheckBoxGroup", "Walker_Unit/Walker_Unit/N_A", "N A");
makeVocab("CheckBoxGroup", "Walker_Unit/Walker_Unit/Chronology", "Chronology");
makeVocab("CheckBoxGroup", "Walker_Unit/Walker_Unit/Fragment", "Fragment");
makeVocab("CheckBoxGroup", "Walker_Unit/Walker_Unit/Wear", "Wear");


/******************************************************************************/
/*                                 VALIDATION                                 */
/******************************************************************************/
/* `ref`  is a reference/path to a field
 * `name` is a human-readable name for that field
 * `cond` is a String containing a boolean expression that evaluates to true if
 *        and only if the the field pair returned by this function should be
 *        validated.
 *
 *  Returns a field pair (really just an ArrayList).
 */
fieldPair(String ref, String name, String cond) {
  List fp = new ArrayList();
  fp.add(ref);
  fp.add(name);
  fp.add(cond);
  return fp;
}

fieldPair(String ref, String name) {
  String t = "true";
  return fieldPair(ref, name, t);
}

/* Returns true if field specified by `ref` is valid. False otherwise.
 */
isValidField(String ref) {
  return !isNull(getFieldValue(ref));
}
/* `format` can either be HTML or PLAINTEXT
 */
validateFields(List fields, String format) {
  Integer numInvalid = 0;

  /* Build validation message string (and count how many invalid fields exist) */
  String out = "Please fill out the following fields:\n";
  for(f : fields) {
    String ref  = f.get(0); // Reference to field
    String name = f.get(1); // Human-readable name
    String cond = f.get(2); // Validation condition

    // Only validate a field whose validation condition evaluates to `true`
    Boolean doValidateField = (Boolean) eval(cond);
    if (!doValidateField)
      continue;

    // Add any invalid fields to the output and tally them
    if (!isValidField(ref)) {
      out += "- " + name + "\n";
      numInvalid++;
    }
  }
  // All the fields are valid; just overwrite `out` with a cheery message
  if (numInvalid == 0)
    out = "All fields contain valid data!";

  /* Format the output as dictated by `format` */
  if (format == "HTML") {
    out = out.replace("\n", "<br>");
  } else if (format == "PLAINTEXT") {
    ;
  }

  return out;
}



/******************************************************************************/
/*                                 AUTOSAVING                                 */
/******************************************************************************/
Map tabgroupToUuid = Collections.synchronizedMap(new HashMap());

getUuid(String tabgroup) {
  tabgroupToUuid.get(tabgroup);
}

setUuid(String tabgroup, String uuid) {
  tabgroupToUuid.put(tabgroup, uuid);
}

saveTabGroup(String tabgroup) {
  saveTabGroup(tabgroup, "");
}

saveTabGroup(String tabgroup, String callback) {
  Boolean enableAutosave      = true;
  String  id                  = getUuid(tabgroup);
  List    geometry            = null;
  List    attributes          = null;
  String  parentTabgroup_     = parentTabgroup;
  String  parentTabgroupUuid_ = getUuid(parentTabgroup_);
  Boolean userWasSet          = !username.equals("");

  String repopulateEntityList;
  repopulateEntityList = "populateEntityListsInTabGroup(\"{tabGroup}\")";
  repopulateEntityList = replaceFirst(repopulateEntityList, "{tabGroup}", parentTabgroup__);

  callback = repopulateEntityList + ";" + callback;

  parentTabgroup = null;

  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      // Make a child-parent relationship if need be.
      if (
          newRecord &&
          !isNull(parentTabgroup_) &&
          !isNull(parentTabgroupUuid_)
      ) {
        String rel = "";
        rel += parentTabgroup_.replaceAll("_", " ");
        rel += " - ";
        rel += tabgroup.replaceAll("_", " ");
        saveEntitiesToHierRel(
          rel,
          parentTabgroupUuid_,
          uuid,
          "Parent Of",
          "Child Of",
          callback
        );
      } else {
        execute(callback);
      }

      // This fixes an interesting bug. Without this, if a user was not set
      // (by calling `setUser`) at the time `saveTabGroup` was first called, but
      // set by the time `onSave` was called, the tab group is saved correctly
      // the first time only.
      //
      // Adding this allows subsequent saves to succeed. Presumably it plays
      // some role in helping FAIMS associate the correct user with a record.
      if (!userWasSet) {
        saveTabGroup(tabgroup, callback);
      }

    }
    onError(message) {
      showToast(message);
    }
  };

  saveTabGroup(tabgroup, id, geometry, attributes, saveCallback, enableAutosave);
}

getTimestampNow() {
  fmt = "yyyy-MM-dd HH:mm:ssZ";
  return getTimestampNow(fmt);
}

getTimestampNow(String fmt) {
  date    = new Date();
  dateFmt = new java.text.SimpleDateFormat(fmt);
  dateStr = dateFmt.format(date);

  // Insert colon into timezone (e.g. +1000 -> +10:00)
  String left; String right;

  left    = dateStr.substring(0, dateStr.length() - 2);
  right   = dateStr.substring(   dateStr.length() - 2);
  dateStr = left + ":" + right;

  return dateStr;
}

populateAuthorAndTimestamp(String tabgroup) {
  Map tabgroupToAuthor    = new HashMap();
  Map tabgroupToTimestamp = new HashMap();

  String authorPath    = tabgroupToAuthor.get(tabgroup);
  String timestampPath = tabgroupToTimestamp.get(tabgroup);

  String authorVal    = username;
  String timestampVal = getTimestampNow();

  if (!isNull(authorPath))    setFieldValue(authorPath,    authorVal);
  if (!isNull(timestampPath)) setFieldValue(timestampPath, timestampVal);
}

onShowSurveyUnit () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Survey_Unit");
}
onShowWalkerUnit () {
  // TODO: Add some things which should happen when this tabgroup is shown
  saveTabGroup("Walker_Unit");
}

addOnEvent("Survey_Unit", "show", "onShowSurveyUnit()");
addOnEvent("Walker_Unit", "show", "onShowWalkerUnit()");

onClickLoginUserName () {
  // TODO: Add some things which should happen when this element is clicked
  newTab("Control", true);
}
onClickControlAddNewSurveyUnit () {
  // TODO: Add some things which should happen when this element is clicked
  parentTabgroup__ = "Control";
  newSurveyUnit();
}
onClickSurveyUnitAddNewWalkerUnit () {
  // TODO: Add some things which should happen when this element is clicked
  String tabgroup = "Survey_Unit";
  if (isNull(getUuid(tabgroup))){
    showToast("{You_must_save_this_tabgroup_first}");
    return;
  }
  parentTabgroup   = tabgroup;
  parentTabgroup__ = tabgroup;
  newWalkerUnit();
}

addOnEvent("Login/Login/User_Name", "click", "onClickLoginUserName()");
addOnEvent("Control/Main/Add_New_Survey_Unit", "click", "onClickControlAddNewSurveyUnit()");
addOnEvent("Survey_Unit/Survey_Unit/Add_New_Walker_Unit", "click", "onClickSurveyUnitAddNewWalkerUnit()");


/******************************************************************************/
/*                             NAVIGATION DRAWER                              */
/******************************************************************************/
removeNavigationButtons() {
  removeNavigationButton("new");
  removeNavigationButton("duplicate");
  removeNavigationButton("delete");
  removeNavigationButton("validate");
}

addNavigationButtons(String tabgroup) {
  removeNavigationButtons();
  List tabgroupsToValidate = new ArrayList();

  addNavigationButton("new", new ActionButtonCallback() {
    actionOnLabel() {
      "{New}";
    }
    actionOn() {
      if(isNull(getUuid(tabgroup))) {
          newRecord(tabgroup);
          showToast("{New_record_created}");
      } else {
          showAlert("{Warning}", "{Any_unsaved_changes_will_be_lost}", "newRecord(\""+tabgroup+"\")", "");
      }
    }
  }, "success");
  addNavigationButton("duplicate", new ActionButtonCallback() {
    actionOnLabel() {
      "{Duplicate}";
    }
    actionOn() {
      if(!isNull(getUuid(tabgroup))) {
          duplicateRecord(tabgroup);
      } else {
          showWarning("{Warning}", "{This_record_is_unsaved_and_cannot_be_duplicated}");
      }
    }
  }, "primary");
  addNavigationButton("delete", new ActionButtonCallback() {
    actionOnLabel() {
      "{Delete}";
    }
    actionOn() {
      deleteRecord(tabgroup);
    }
  }, "danger");
  if (tabgroupsToValidate.contains(tabgroup)) {
    addNavigationButton("validate", new ActionButtonCallback() {
      actionOnLabel() {
        "{Validate}";
      }
      actionOn() {
        String validationFunction = "validate" + tabgroup.replaceAll("_", "") + "()";
        eval(validationFunction);
      }
    }, "default");
  }
}

/******************************************************************************/
/*        ENTITY AND RELATIONSHIP SAVING AND LOADING HELPER FUNCTIONS         */
/******************************************************************************/
/** Saves two entity id's as a relation. **/
saveEntitiesToRel(String type, String entity1, String entity2) {
  String callback = null;
  saveEntitiesToRel(type, entity1, entity2, callback);
}

/** Saves two entity id's as a relation with some callback executed. **/
saveEntitiesToRel(String type, String entity1, String entity2, String callback) {
  String e1verb = null;
  String e2verb = null;
  saveEntitiesToHierRel(type, entity1, entity2, e1verb, e2verb, callback);
}

/** Saves two entity id's as a hierachical relation with some callback executed. **/
saveEntitiesToHierRel(String type, String entity1, String entity2, String e1verb, String e2verb, String callback) {
  if (isNull(entity1) || isNull(entity2)) return;
  saveRel(null, type, null, null, new SaveCallback() {
    onSave(rel_id, newRecord) {
      addReln(entity1, rel_id, e1verb);
      addReln(entity2, rel_id, e2verb);
      if(!isNull(callback)) {
         execute(callback);
      }
    }
    onError(message) {
      Log.e("saveEntitiesToHierRel", message);
      showToast(message);
    }
  });
}

// Makes a new record of the given tabgroup
newRecord(String tabgroup) {
  cancelTabGroup(tabgroup, false);

  String newTabGroupFunction = "new" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "newTabgroup()"
  eval(newTabGroupFunction);

  Log.d("newRecord", tabgroup);
}

// Deletes the current record of the given tabgroup
deleteRecord(String tabgroup) {
  String deleteTabGroupFunction = "delete" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "deleteTabgroup()"
  eval(deleteTabGroupFunction);

  Log.d("deleteRecord", tabgroup);
}

// Duplicates the current record of the given tabgroup
duplicateRecord(String tabgroup) {
  dialog = showBusy("Duplicating", "Please wait...");

  String duplicateTabGroupFunction = "duplicate" + tabgroup.replaceAll("_", "") + "()"; // Typical value: "duplicateTabgroup()"
  eval(duplicateTabGroupFunction);

  Log.d("duplicateRecord", tabgroup);
}

// generic fetch saved attributes query
getDuplicateAttributeQuery(String originalRecordID, String attributesToDupe) {
  if (attributesToDupe.equals("")) {
    attributesToDupe = "''";
  }
  String duplicateQuery = "SELECT attributename, freetext, vocabid, measure, certainty " +
                          "  FROM latestnondeletedaentvalue JOIN attributekey USING (attributeid) " +
                          " WHERE attributename IN ('', "+attributesToDupe+") " +
                          "   AND uuid = '"+originalRecordID+"'; ";
  return duplicateQuery;
}

getDuplicateRelnQuery(String originalRecordID) {
  String dupeRelnQuery = "SELECT relntypename, parentparticipatesverb, childparticipatesverb, parentuuid "+
                         "  FROM parentchild join relationship using (relationshipid) "+
                         "  JOIN relntype using (relntypeid) "+
                         " WHERE childuuid = '"+originalRecordID+"' " +
                         "   AND parentparticipatesverb = 'Parent Of' ";
  return dupeRelnQuery;
}

makeDuplicateRelationships(fetchedAttributes, String newuuid){
  Log.e("Module", "makeDuplicateRelationships");
  for (savedAttribute : fetchedAttributes){
    //  saveEntitiesToHierRel(relnname, parent, child, parentverb, childverb, relSaveCallback);
    //relntypename, parentparticipatesverb, childparticipatesverb, childuuid
    String relntypename           = savedAttribute.get(0);
    String parentparticipatesverb = savedAttribute.get(1);
    String childparticipatesverb  = savedAttribute.get(2);
    String childuuid              = savedAttribute.get(3);
    saveEntitiesToHierRel(relntypename, newuuid, childuuid, parentparticipatesverb, childparticipatesverb, null);
  }
}

// generic get extra attributes
getExtraAttributes(fetchedAttributes) {
  List extraAttributes = createAttributeList();
  Log.d("Module", "Duplicating fetched attributes: " + fetchedAttributes.toString());
  for (savedAttribute : fetchedAttributes) {
    extraAttributes.add(
      createEntityAttribute(
        savedAttribute.get(0),
        savedAttribute.get(1),
        savedAttribute.get(2),
        savedAttribute.get(3),
        savedAttribute.get(4)
      )
    );
  }
  return extraAttributes;
}

loadEntity() {
  loadEntity(false);
}
loadEntity(Boolean isDropdown) {
  if (isDropdown) {
    loadEntityFrom(getDropdownItemValue());
  } else {
    loadEntityFrom(getListItemValue());
  }
}

loadEntityFrom(String entityID) {
  if (isNull(entityID)) {
    Log.e("Module", "Cannot load an entity with a null ID.");
    return;
  }

  String getEntTypeNameQ = "SELECT aenttypename " +
                           "  FROM latestnondeletedarchent " +
                           "  JOIN aenttype " +
                           " USING (aenttypeid) " +
                           " WHERE uuid = '" + entityID + "'";
  fetchAll(getEntTypeNameQ, new FetchCallback() {
    onFetch(result) {
      String archEntName = result.get(0).get(0);
      String loadFunction = "load" + archEntName.replaceAll(" ", "") + "From(entityID)"; // Typical value: loadContextFrom(entityID)
      eval(loadFunction);
    }
  });
}

newSurveyUnit(){
  String tabgroup = "Survey_Unit";

  String autoNumSource = "";
  autoNumSource = getFieldValue("Control/Main/Next_Survey_Unit_ID");
  if (isNull(autoNumSource)) {
    showWarning("{Alert}","{A_next_ID_has_not_been_entered_please_provide_one}");
    return;
  }

  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  String autoNumDest = "";
  autoNumDest = "Survey_Unit/Survey_Unit/Survey_Unit_ID";
  incAutoNum(autoNumDest);
  onCreateSurveyUnit__();

  // Deprecated. Maintains backwards compatibility.
  onCreateSurveyUnit();
}

// Deprecated. Maintains backwards compatibility.
onCreateSurveyUnit(){ return; }

onCreateSurveyUnit__(){
  String ref      = "Survey_Unit";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}


// Deprecated. Maintains backwards compatibility.
onFetchSurveyUnit(){ return; }

// Triggered after an existing record is loaded.
onFetchSurveyUnit__(){
  String ref      = "Survey_Unit";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

duplicateSurveyUnit(){
  String tabgroup = "Survey_Unit";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);

  String autoNumDest = "";
  autoNumDest = "Survey_Unit/Survey_Unit/Survey_Unit_ID";
  incAutoNum(autoNumDest);

  clearGpsInTabGroup(tabgroup);



  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());
          makeDuplicateRelationships(result, getUuid(tabgroup));
          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup, getUuid(tabgroup), null, null, new SaveCallback(){
        onSave(autosaveUuid, autosaveNewRecord) {
          setUuid(tabgroup, autosaveUuid);
        }
      }, enable_autosave);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

deleteSurveyUnit(){
  String tabgroup = "Survey_Unit";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteSurveyUnit()", "doNotDelete()");
  }
}

reallyDeleteSurveyUnit(){
  String tabgroup = "Survey_Unit";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}

newWalkerUnit(){
  String tabgroup = "Walker_Unit";


  setUuid(tabgroup, null);
  newTabGroup(tabgroup);
  populateAuthorAndTimestamp(tabgroup);
  populateEntityListsInTabGroup(tabgroup);
  onCreateWalkerUnit__();

  // Deprecated. Maintains backwards compatibility.
  onCreateWalkerUnit();
}

// Deprecated. Maintains backwards compatibility.
onCreateWalkerUnit(){ return; }

onCreateWalkerUnit__(){
  String ref      = "Walker_Unit";
  String event    = "create";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}


// Deprecated. Maintains backwards compatibility.
onFetchWalkerUnit(){ return; }

// Triggered after an existing record is loaded.
onFetchWalkerUnit__(){
  String ref      = "Walker_Unit";
  String event    = "fetch";
  String stmtsStr = getStatementsString(ref, event);
  execute(stmtsStr);
}

duplicateWalkerUnit(){
  String tabgroup = "Walker_Unit";
  String uuidOld = getUuid(tabgroup);

  disableAutoSave(tabgroup);


  clearGpsInTabGroup(tabgroup);



  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      populateAuthorAndTimestamp(tabgroup);

      Boolean enable_autosave = true;

      fetchAll(getDuplicateRelnQuery(uuidOld), new FetchCallback(){
        onFetch(result) {
          Log.e("Module", result.toString());
          makeDuplicateRelationships(result, getUuid(tabgroup));
          showToast("{Duplicated_record}");
          dialog.dismiss();
        }
      });

      saveTabGroup(tabgroup, getUuid(tabgroup), null, null, new SaveCallback(){
        onSave(autosaveUuid, autosaveNewRecord) {
          setUuid(tabgroup, autosaveUuid);
        }
      }, enable_autosave);
    }
  };

  String extraDupeAttributes = "";
  fetchAll(getDuplicateAttributeQuery(getUuid(tabgroup), extraDupeAttributes), new FetchCallback(){
    onFetch(result) {
      excludeAttributes = new ArrayList();

      duplicateTabGroup(tabgroup, null, getExtraAttributes(result), excludeAttributes, saveCallback);
    }
  });
}

deleteWalkerUnit(){
  String tabgroup = "Walker_Unit";

  if (isNull(getUuid(tabgroup))) {
    cancelTabGroup(tabgroup, true);
  } else {
    showAlert("{Confirm_Deletion}", "{Press_OK_to_Delete_this_Record}", "reallyDeleteWalkerUnit()", "doNotDelete()");
  }
}

reallyDeleteWalkerUnit(){
  String tabgroup = "Walker_Unit";
  deleteArchEnt(getUuid(tabgroup));
  cancelTabGroup(tabgroup, false);
}


doNotDelete(){
  showToast("{Delete_Cancelled}");
}
addOnEvent("Login", "show", "removeNavigationButtons()");
addOnEvent("Control", "show", "removeNavigationButtons()");
addOnEvent("Survey_Unit", "show", "addNavigationButtons(\"Survey_Unit\")");
addOnEvent("Walker_Unit", "show", "addNavigationButtons(\"Walker_Unit\")");

/******************************************************************************/
/*                                   SEARCH                                   */
/******************************************************************************/
addOnEvent("Control/Search"               , "show"  , "search();");
addOnEvent("Control/Search/Entity_List"   , "click" , "loadEntity();");
addOnEvent("Control/Search/Search_Button" , "click" , "search()");
addOnEvent("Control/Search/Search_Term"   , "click" , "clearSearch()");
addOnEvent("Control/Search/Entity_Types"  , "click" , "search()");

entityTypes = new ArrayList();
entityTypes.add(new NameValuePair("{All}", ""));
entityTypes.add(new NameValuePair("{Survey_Unit}", "Survey Unit"));
entityTypes.add(new NameValuePair("{Walker_Unit}", "Walker Unit"));
populateDropDown("Control/Search/Entity_Types", entityTypes);

clearSearch(){
  setFieldValue("Control/Search/Search_Term","");
}

search(){
  String tabgroup = "Control";
  String refEntityList  = tabgroup + "/Search/Entity_List";
  String refSearchTerm  = tabgroup + "/Search/Search_Term";
  String refEntityTypes = tabgroup + "/Search/Entity_Types";

  String type = getFieldValue(refEntityTypes);
  String term = getFieldValue(refSearchTerm);
  String searchQuery = "SELECT uuid, response "+
                       "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
                       " WHERE uuid in (SELECT uuid "+
                       "                  FROM latestNonDeletedArchEntIdentifiers "+
                       "                 WHERE measure LIKE '"+term+"'||'%'  "+
                       "                   AND ( aenttypename LIKE '"+type+"' OR '' = '"+type+"' ) "+
                       "                )  "+
                       " ORDER BY response "+
                       " LIMIT ? "+
                       "OFFSET ? ";

  populateCursorList(refEntityList, searchQuery, 25);
  refreshTabgroupCSS(tabgroup);

  Log.d("Module", "Search query: " + searchQuery);
}

loadSurveyUnitFrom(String uuid) {
  String tabgroup = "Survey_Unit";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      onFetchSurveyUnit__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}

loadWalkerUnitFrom(String uuid) {
  String tabgroup = "Walker_Unit";
  setUuid(tabgroup, uuid);
  if (isNull(uuid)) return;

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      populateEntityListsInTabGroup(tabgroup);
      onFetchWalkerUnit__();
    }
  };

  showTabGroup(tabgroup, uuid, cb);
}


/******************************************************************************/
/*                          TAKE FROM GPS BUTTON(S)                           */
/******************************************************************************/

clearGpsInTabGroup(String tabgroup) {
  Map tabgroupToTabRef = new HashMap();


  String tabRef = tabgroupToTabRef.get(tabgroup);
  if (isNull(tabRef)) return;

  clearGpsInTab(tabRef);
}

clearGpsInTab(String tabRef) {
  setFieldValue(tabRef + "Accuracy"  , "");
  setFieldValue(tabRef + "Latitude"  , "");
  setFieldValue(tabRef + "Longitude" , "");
  setFieldValue(tabRef + "Easting"   , "");
  setFieldValue(tabRef + "Northing"  , "");
}

/******************************************************************************/
/*                       AUTONUMBERING HELPER FUNCTIONS                       */
/******************************************************************************/
/*
 * If value of field specified by `ref` is null, sets the field to `defaultVal`,
 * otherwise increments its value.
 *
 * Returns the value the field was updated to.
 */
incField(String ref, Integer defaultVal) {
  String val = getFieldValue(ref);

  if (isNull(val)) {
    setFieldValue(ref, defaultVal);
    return defaultVal;
  }

  Integer inc = Integer.parseInt(val) + 1;
  setFieldValue(ref, inc);
  insertIntoLocalSettings(ref, inc.toString());

  return inc;
}

/* Increments the field at `ref` or returns null if it does not contain a
 * number.
 */
incField(String ref) {
  return incField(ref, 1);
}

addOnEvent("Control", "show", "onShowAutonum()");

getStartingIdPaths() {
  List l = new ArrayList();
  l.add("Control/Main/Next_Survey_Unit_ID");

  return l;
}

onShowAutonum() {
  List l = getStartingIdPaths();

  for (ref : l) {
    loadStartingId(ref);
  }
}

loadStartingId(String ref) {
  String idQ = "SELECT value FROM localSettings WHERE key = '" + ref + "';";
  fetchOne(idQ, new FetchCallback() {
    onFetch(result) {
      if (isNull(result)) setFieldValue(ref, "1"          );
      else                setFieldValue(ref, result.get(0));
    }
  });
}

/*
 * Sets bindings to save autonum'd fields whenever they're blurred.
 */
for (ref : getStartingIdPaths()) {
  onFocus(ref, null, "insertIntoLocalSettings(\"" + ref + "\", getFieldValue(\"" + ref + "\"));");
}

incAutoNum(String destPath) {
  Map destToSource = new HashMap();
  destToSource.put("Survey_Unit/Survey_Unit/Survey_Unit_ID", "Control/Main/Next_Survey_Unit_ID");

  String sourcePath = destToSource.get(destPath);
  String destVal    = getFieldValue(sourcePath);
  setFieldValue(destPath, destVal);
  incField(sourcePath);
}

/******************************************************************************/
/*                POPULATION OF ENTITY AND CHILD ENTITY LISTS                 */
/******************************************************************************/
/*
 * `viewType`   the type of GUI element to be populated. It can either equal
 *              "DropDown" or "List".
 * `path`       the reference of the GUI element to be populated.
 * `parentUuid` the parent in the relationship denoted by `relType`.
 * `entType`    the type of the entities the menu will be populated with.
 * `relType`    the name of the relationship the children are to be in with the
 *              entity denoted by `parentUuid`.
 */
populateMenuWithEntities (
  String viewType,
  String path,
  String parentUuid,
  String entType,
  String relType
) {
  String getChildEntitiesQ = "" +
    "SELECT childuuid, response "+
    "  FROM parentchild JOIN latestNonDeletedArchEntFormattedIdentifiers ON (childuuid = uuid) " +
    "  JOIN createdmodifiedatby USING (uuid) " +
    " WHERE relationshipid IN (SELECT relationshipid  " +
    "                            FROM latestnondeletedrelationship JOIN relntype USING (relntypeid) " +
    "                           WHERE relntypename = '"+relType+"') " +
    "   AND parentuuid = " + parentUuid + " " +
    "   AND (childaenttypename = '"+entType+"' OR '"+entType+"' = '') " +
    " ORDER BY createdat DESC ";

  String getEntitiesQ = "" +
    "SELECT uuid, response "+
    "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
    " WHERE uuid in (SELECT uuid "+
    "                  FROM latestNonDeletedArchEntIdentifiers "+
    "                 WHERE aenttypename = '"+entType+"' OR '"+entType+"' = '' " +
    "               )  "+
    " ORDER BY response ";

  String q = null;
  if (relType.equals("")) {
    q = getEntitiesQ;
  } else {
    q = getChildEntitiesQ;
  }

  FetchCallback cbPopulateDropDown = new FetchCallback() {
    onFetch(result) {
      populateDropDown(path, result, true);
    }
  };

  switch (viewType) {
    case "DropDown":
      fetchAll(q, cbPopulateDropDown);
      break;
    case "List":
      q += " LIMIT ? OFFSET ? ";
      populateCursorList(path, q, 25);
      break;
    default:
      Log.e("populateMenuWithEntities ", "Unexpected type '" + viewType + "'");
  }
}

populateEntityListsInTabGroup(String tabGroup) {
  if (isNull(tabGroup)) {
    return;
  }

  for (m : ENTITY_MENUS) {
    String path         = m[1];
    String menuTabGroup = getTabGroupRef(path);
    String functionCall = getEntityMenuPopulationFunction(m);

    if (menuTabGroup.equals(tabGroup))
      execute(functionCall);
  }
}

getEntityMenuPopulationFunction(String[] menuDescriptor) {
  String viewType       = menuDescriptor[0];
  String path           = menuDescriptor[1];
  String parentUuidCall = menuDescriptor[2];
  String entType        = menuDescriptor[3];
  String relType        = menuDescriptor[4];

  String functionCall = "";
  functionCall += "populateMenuWithEntities(";
  functionCall += "\"" + viewType       + "\"";
  functionCall += ", ";
  functionCall += "\"" + path           + "\"";
  functionCall += ", ";
  functionCall +=        parentUuidCall       ;
  functionCall += ", ";
  functionCall += "\"" + entType        + "\"";
  functionCall += ", ";
  functionCall += "\"" + relType        + "\"";
  functionCall += ")";

  return functionCall;
}

ENTITY_MENUS = new ArrayList();
ENTITY_MENUS.add(new String[] {
  "List",
  "Survey_Unit/Survey_Unit/Walker_Units",
  "getUuid(\"Survey_Unit\")",
  "Walker Unit",
  "Survey Unit - Walker Unit",
});
for (m : ENTITY_MENUS) {
  String path         = m[1];
  String functionCall = getEntityMenuPopulationFunction(m);

  execute(functionCall);
}
addOnEvent("Survey_Unit/Survey_Unit/Walker_Units", "click", "loadEntity()");

/******************************************************************************/
/*                             HANDWRITTEN LOGIC                              */
/******************************************************************************/

/************************* SURVEY UNIT ID POPULATION **************************/
  setWebViewToIdentifier(String ref, String tabGroup) {
    String uuid = getUuid(tabGroup);

    if (isNull(uuid)) {
      populateWebViewHtml(ref, "&nbsp;");
      return;
    }

    String q = "";
    q += "SELECT uuid, response ";
    q += "  FROM latestnondeletedarchentformattedidentifiers ";
    q += " WHERE uuid = '%s' ";
    q  = replaceFirst(q, uuid);

    cb = new FetchCallback() {
      onFetch(result) {
        identifier  = result.get(1);

        populateWebViewHtml(ref, identifier);
      }
    };

    fetchOne(q, cb);
  }

  updateSurveyUnitId() {
    String parentTabGroup = "Survey_Unit";
    String ref            = "Walker_Unit/Walker_Unit/Survey_Unit_ID";
    setWebViewToIdentifier(ref, parentTabGroup);
  }

  // TODO: This doesn't work with search
  addOnEvent("Walker_Unit", "create", "updateSurveyUnitId()");
  addOnEvent("Walker_Unit", "fetch",  "updateSurveyUnitId()");

/************************************ GRID ************************************/
  import java.util.concurrent.Semaphore;

  getGridHtml(
      int numberOfRows,   int numberOfWalkers,
      int highlightedRow, int highlightedWalker,
      int selectedRow,    int selectedWalker
  ) {
    // In a probably vain attempt to improve performance, this code is valid
    // HTML5.
    String html = "";

    html += "<!DOCTYPE html>";
    html += "<html>";
    html += "  <head>";
    html += "    <title>Grid</title>";
    html += "    <style>";
    html += "      table {";
    html += "        width: 100%;";
    html += "        border-collapse: separate;";
    html += "        border-spacing:  0px;";
    html += "      }";
    html += "      td {";
    html += "        padding: 3px;";
    html += "        border: 1px solid #000000;";
    html += "      }";
    html += "      td.highlighted {";
    html += "        padding: 0px;";
    html += "        border:  3px double #000000;";
    html += "        background-color: #CCCCCC;";
    html += "      }";
    html += "      td.selected {";
    html += "        background-color: #00AA00;";
    html += "        color:            #FFFFFF;";
    html += "      }";
    html += "    </style>";
    html += "  </head>";
    html += "  <table>";

    for (int i = numberOfRows; i >= 1; i--) {
      html += "    <tr>";
      for (int j = 1; j <= numberOfWalkers; j++) {
        Boolean isHighlighted = (i == highlightedRow && j == highlightedWalker);
        Boolean isSelected    = (i == selectedRow    && j == selectedWalker);

        String  cssClass = "";
        if (isHighlighted) cssClass += " highlighted";
        if (isSelected)    cssClass += " selected";

        String htmlRow = "";
        htmlRow += "      <td class=\"{cssClass}\">";
        htmlRow += "        Row {row}, Walker {walker}";
        htmlRow += "      </td>";
        htmlRow  = replaceFirst(htmlRow, "{cssClass}", cssClass);
        htmlRow  = replaceFirst(htmlRow, "{row}",      i);
        htmlRow  = replaceFirst(htmlRow, "{walker}",   j);

        html += htmlRow;
      }
      html += "    </tr>";
    }
    html += "  </table>";
    html += "</html>";

    return html;
  }

  getFieldValueAsInt(String ref) {
    String  val      = getFieldValue(ref);
    int valAsInteger = 0;

    try {
      valAsInteger = Integer.valueOf(val);
    } catch (Exception e) { ; }

    return valAsInteger.intValue();
  }

  clip(int x, int min, int max) {
    if (x > max) return max;
    if (x < min) return min;
    return x;
  }

  numberOfRows() {
    String ref = "Control/Vars/Number_of_Rows";
    return getFieldValueAsInt(ref);
  }

  // A mutex is required for `numberOfRows(int)` to handle users double-clicking
  // the 'Add Row' and 'Delete Row' buttons.
  MUTEX_WALKER_UNIT_ROWS = new Semaphore(1);

  /* It is assumed that this function is only ever called while "Walker_Unit" is
   * displayed.
   */
  numberOfRows(int val) {
    numberOfRows(val, "");
  }

  numberOfRows(int val, String callback) {
    if (val < 1) val = 1; // `val` cannot be lower than 1.

    String refRowsControl    = "Control/Vars/Number_of_Rows";
    String refRowsSurveyUnit = "Survey_Unit/Vars/Number_of_Rows";
    String parentTabGroup    = getTabGroupRef(refRowsSurveyUnit);
    String parentUuid        = getUuid       (parentTabGroup);
    String parentArchEntType = getArchEntType(parentTabGroup);
    String attrName          = getAttributeName(refRowsSurveyUnit);
    String numberOfRows      = String.valueOf(val);
    List   geometry          = null;
    List   attributes        = createAttributeList();

    if (!getDisplayedTabGroup().equals("Walker_Unit"))
      return;

    if (!MUTEX_WALKER_UNIT_ROWS.tryAcquire()) {
      return;
    }

    // 1. If getPreviousTabGroup() == parentTabGroup, the user will visit it
    //    when they hit the back button. In this case, the value saved in the db
    //    must be made consistent with the one in the UI.
    if (getPreviousTabGroup().equals(parentTabGroup)) {
      setFieldValue(refRowsSurveyUnit, numberOfRows);
    }

    // 2. Also update the value in `refRowsControl`, which is used as a global
    //   variable.
    setFieldValue(refRowsControl, numberOfRows);

    // 3. Update 'Number of Rows' using saveArchEnt
    SaveCallback release = new SaveCallback() {
      onSave(uuid, newRecord) {
        execute(callback);
        MUTEX_WALKER_UNIT_ROWS.release();
      }
    };

    Object a = createEntityAttribute(attrName, null, null, numberOfRows, null);
    attributes.add(a);

    saveArchEnt(parentUuid, parentArchEntType, geometry, attributes, release);

    // 4. If the cursor (i.e. `highlightedRow()`) has changed, the entity under-
    //    neath it should be loaded.
    if (selectedRow() > highlightedRow()) {
      highlightedWalker(selectedWalker());
      loadWalkerUnit();
    }
  }

  highlightedRow() {
    String ref = "Control/Vars/Highlighted_Row";
    int    val = getFieldValueAsInt(ref);

    return clip(val, 1, numberOfRows());
  }

  highlightedRow(int val) {
    val = clip(val, 1, numberOfRows());

    String ref = "Control/Vars/Highlighted_Row";
    setFieldValue(ref, String.valueOf(val));
  }

  selectedRow() {
    String ref = "Walker_Unit/Vars/Row_ID";
    return getFieldValueAsInt(ref);
  }

  numberOfWalkers() {
    String ref = "Control/Vars/Number_of_Walkers";
    return getFieldValueAsInt(ref);
  }

  highlightedWalker() {
    String ref = "Control/Vars/Highlighted_Walker";
    int    val = getFieldValueAsInt(ref);

    return clip(val, 1, numberOfWalkers());
  }

  highlightedWalker(int val) {
    val = clip(val, 1, numberOfWalkers());

    String ref = "Control/Vars/Highlighted_Walker";
    setFieldValue(ref, String.valueOf(val));
  }

  selectedWalker() {
    String ref = "Walker_Unit/Vars/Walker_ID";
    return getFieldValueAsInt(ref);
  }

  moveWalker(int delta) {
    highlightedWalker(highlightedWalker() + delta);
  }

  moveRow(int delta) {
    highlightedRow(highlightedRow() + delta);
  }

  initHighlighted() {
    highlightedRow   (1);
    highlightedWalker(1);
  }

  redrawGrid() {
    String ref  = "Walker_Unit/Walker_Unit/Grid";
    String html = getGridHtml(
        numberOfRows(),   numberOfWalkers(),
        highlightedRow(), highlightedWalker(),
        selectedRow(),    selectedWalker()
    );
    populateWebViewHtml(ref, html);
  }

  zeroRow() {
    String rowId          = String.valueOf(highlightedRow());
    String tabgroup       = "Walker_Unit";
    String parentTabGroup = "Survey_Unit";
    String parentUuid     = getUuid(parentTabGroup);

    String q = "";
    q += " SELECT measure AS savedWalkerIds";
    q += "   FROM latestnondeletedaentvalue";
    q += "   JOIN attributekey USING (attributeid)";
    q += "  WHERE attributename = 'Walker ID'";
    q += "    AND uuid IN (";
    q += "         SELECT uuid";
    q += "           FROM latestnondeletedaentvalue";
    q += "           JOIN attributekey USING (attributeid)";
    q += "           JOIN parentchild ON (uuid = childuuid)";
    q += "          WHERE measure = '{rowId}'";
    q += "            AND attributename = 'Row ID'";
    q += "            AND parentuuid = '{parentUuid}'";
    q += "        )";
    q  = replaceFirst(q, "{rowId}",      rowId);
    q  = replaceFirst(q, "{parentUuid}", parentUuid);

    FetchCallback zeroRow = new FetchCallback() {
      onFetch(result) {
        zeroRow(result);
      }
    };

    fetchAll(q, zeroRow);
  }

  zeroRow(result) {
    List   savedWalkerIds = new ArrayList();
    List     allWalkerIds = new ArrayList();
    List unsavedWalkerIds = new ArrayList();

    // Populate `savedWalkerIds`
    for (qRow : result) {
      String savedWalkerId = qRow.get(0);
      savedWalkerIds.add(savedWalkerId);
    }

    // Populate `allWalkerIds`
    for (int i = 1; i <= numberOfWalkers(); i++) {
      String unsavedWalkerId = String.valueOf(i);
      unsavedWalkerIds.add(unsavedWalkerId);
    }

    // Compute `unsavedWalkerIds`
    allWalkerIds.removeAll(savedWalkerIds);
    unsavedWalkerIds = allWalkerIds;

    // Create "Walker Unit" records which were previously unsaved
    String       parentUuid = getUuid("Survey_Unit");
    String       uuid       = null;
    String       entityType = "Walker Unit";
    List         geometry   = null;
    List         attributes = createAttributeList();
    SaveCallback relate     = new SaveCallback() {
      onSave(uuid, newRecord) {
        saveEntitiesToHierRel(
          "Survey Unit - Walker Unit",
          parentUuid,
          uuid,
          "Parent Of",
          "Child Of",
          ""
        );
      }
    };
    saveArchEnt(uuid, entityType, geometry, attributes, relate);
  }

  nextRow() {
    if (highlightedRow() == numberOfRows()) {
      numberOfRows(numberOfRows() + 1, "nextRow()");
    } else {
      moveWalker(-999);
      moveRow(+1);
      loadWalkerUnit();
    }
  }

  nextWalkerUnit () {
    if (highlightedWalker() == numberOfWalkers()) {
      nextRow();
    } else {
      moveWalker(+1);
      loadWalkerUnit();
    }
  }

  gridUp   () { moveRow   (+1); redrawGrid(); }
  gridDown () { moveRow   (-1); redrawGrid(); }
  gridLeft () { moveWalker(-1); redrawGrid(); }
  gridRight() { moveWalker(+1); redrawGrid(); }

  addRow   () { numberOfRows(numberOfRows() + 1); redrawGrid(); }
  deleteRow() { numberOfRows(numberOfRows() - 1); redrawGrid(); }

  MUTEX_WALKER_ZERO_ROW = new Semaphore(1);
  zeroRowAndNext() {
    if (MUTEX_WALKER_ZERO_ROW.drainPermits() == 0) {
      return;
    }

    dialog = showBusy("Confirming Zero Entries", "Please wait...");
    zeroRow();
    nextRow();
  }

  zeroRowAndNextComplete() {
    if (dialog != null) {
      dialog.dismiss();
    }
    MUTEX_WALKER_ZERO_ROW.release();
  }

  inheritSurveyUnitFields() {
    copyFieldValue(
      "Control/Main/Number_of_Rows",
      "Control/Vars/Number_of_Rows",
      false
    );
    copyFieldValue(
      "Control/Main/Number_of_Walkers",
      "Control/Vars/Number_of_Walkers",
      false
    );

    copyFieldValue(
      "Control/Main/Number_of_Rows",
      "Survey_Unit/Vars/Number_of_Rows",
      false
    );
    copyFieldValue(
      "Control/Main/Number_of_Walkers",
      "Survey_Unit/Vars/Number_of_Walkers",
      false
    );
    copyFieldValue(
      "Control/Main/Row_Interval",
      "Survey_Unit/Vars/Row_Interval",
      false
    );
    copyFieldValue(
      "Control/Main/Walker_Interval",
      "Survey_Unit/Vars/Walker_Interval",
      false
    );
  }

  onCreateSurveyUnit() {
    inheritSurveyUnitFields();
  }

  inheritWalkerUnitFields() {
    setFieldValue(
      "Walker_Unit/Vars/Row_ID",
      String.valueOf(highlightedRow())
    );
    setFieldValue(
      "Walker_Unit/Vars/Walker_ID",
      String.valueOf(highlightedWalker())
    );
  }

  onCreateWalkerUnit() {
    inheritWalkerUnitFields();
    redrawGrid();
    zeroIfBlank();
  }

  /* Fetches the 'Number of Rows' and 'Number of Walkers' attributes stored in
   * the parent and loads them into the global vars. Here we have used fields
   * as globals.
   */
  updateGridDimsVars() {
    String tabgroup   = "Walker_Unit";
    String childUuid  = getUuid(tabgroup);

    String q = "";
    q += " SELECT attributename, measure";
    q += "   FROM latestnondeletedaentvalue";
    q += "   JOIN attributekey USING (attributeid)";
    q += "   JOIN parentchild ON (uuid = parentuuid)";
    q += "  WHERE attributename IN ('Number of Rows', 'Number of Walkers')";
    q += "    AND childuuid = '{childUuid}'";
    q  = replaceFirst(q, "{childUuid}", childUuid);

    FetchCallback updateGridDimsVars = new FetchCallback() {
      onFetch(result) {
        updateGridDimsVars(result);
        redrawGrid();
      }
    };

    fetchAll(q, updateGridDimsVars);
    updateWalkerUnitParentVars(childUuid);
  }

  updateGridDimsVars(result) {
    String refRows    = "Control/Vars/Number_of_Rows";
    String refWalkers = "Control/Vars/Number_of_Walkers";

    String attrNameRows    = getAttributeName(refRows);
    String attrNameWalkers = getAttributeName(refWalkers);

    if (result == null) return;
    for (row : result) {
      String attrName = row.get(0);
      String attrVal  = row.get(1);

      if (attrName.equals(attrNameRows   )) setFieldValue(refRows,    attrVal);
      if (attrName.equals(attrNameWalkers)) setFieldValue(refWalkers, attrVal);
    }
  }

  updateWalkerUnitParentVars(String childUuid) {
    updateWalkerUnitParentVars(childUuid, "");
  }

  updateWalkerUnitParentVars(String childUuid, String callback) {
    String q = "";
    q += " SELECT parentuuid";
    q += "   FROM parentchild";
    q += "  WHERE childuuid='{childUuid}'";
    q += "    AND parentparticipatesverb='Parent Of'";
    q  = replaceFirst(q, "{childUuid}", childUuid);

    FetchCallback updateWalkerUnitParentVars = new FetchCallback() {
      onFetch(result) {
        parentTabgroup   = "Survey_Unit";
        parentTabgroup__ = "Survey_Unit";

        if (result        == null) { execute(callback); return; }
        if (result.size() == 0   ) { execute(callback); return; }

        String parentUuid = result.get(0).get(0);
        setUuid(parentTabgroup, parentUuid);

        execute(callback);
      }
    };

    fetchAll(q, updateWalkerUnitParentVars);
  }

  // TODO: Figure out how to get this to work with search.
  // TODO: Loading *might* be broken; The list of child entities in the parent
  // doesn't get refreshed after making a new Walker Unit via a loaded one.
  // TODO: Loading might cause other child entities to be saved with incorrect
  // relationships

  // A mutex is required for `loadWalkerUnit` to handle users double-clicking
  // the load button.
  MUTEX_WALKER_UNIT_LOAD = new Semaphore(1);

  /* This function is intended to be called from the "Walker_Unit" tab group. It
   * is not intended to be called from the *parent of* the "Walker_Unit" tab
   * group.
   */
  loadWalkerUnit() {
    String tabgroup   = "Walker_Unit";
    String childUuid  = getUuid(tabgroup);
    String parentUuid = getUuid(parentTabgroup__);
    String rowId      = String.valueOf(highlightedRow   ());
    String walkerId   = String.valueOf(highlightedWalker());

    // The selected walker unit is already loaded
    if (
        getDisplayedTabGroup().equals(tabgroup) &&
        highlightedRow   () == selectedRow   () &&
        highlightedWalker() == selectedWalker()
    ) {
      return;
    }

    // We are still waiting for a previous `loadWalkerUnit` to complete
    if (!MUTEX_WALKER_UNIT_LOAD.tryAcquire()) {
      return;
    }

    String q = "";
    q += " SELECT uuid";
    q += "   FROM latestnondeletedaentvalue";
    q += "   JOIN attributekey using (attributeid)";
    q += "  WHERE measure = '{walkerId}'";
    q += "    AND attributename = 'Walker ID'";
    q += "    AND uuid IN (";
    q += "                 SELECT uuid";
    q += "                   FROM latestnondeletedaentvalue";
    q += "                   JOIN attributekey USING (attributeid)";
    q += "                   JOIN parentchild ON (uuid = childuuid)";
    q += "                  WHERE measure = '{rowId}'";
    q += "                    AND attributename = 'Row ID'";
    q += "                    AND parentuuid = '{parentUuid}'";
    q += "        );";
    q  = replaceFirst(q, "{rowId}",      rowId);
    q  = replaceFirst(q, "{walkerId}",   walkerId);
    q  = replaceFirst(q, "{parentUuid}", parentUuid);

    FetchCallback loadWalkerUnit = new FetchCallback() {
      onFetch(result) {
        // 1. An "blur" event will not be triggered by the following steps. We
        //    must zero-out all blank fields manually.
        zeroIfBlank();

        // 2. Leaving "Walker_Unit" calls `initHighlighted`, so we must store
        //    (and later restore) the highlighted cell.
        int highlightedRow    = highlightedRow   ();
        int highlightedWalker = highlightedWalker();

        // 3. Leave "Walker_Unit".
        if (getDisplayedTabGroup().equals(tabgroup))
          cancelTabGroup(tabgroup, false);

        // 4. Restore the highlighted cell.
        highlightedRow   (highlightedRow   );
        highlightedWalker(highlightedWalker);

        // 5. Re-enter "Walker_Unit" with the desired record loaded.
        if (result == null || result.size() == 0) {
          parentTabgroup = "Survey_Unit";
          newWalkerUnit();
        } else {
          String uuid = result.get(0).get(0);
          loadWalkerUnitFrom(uuid);
        }

        // 6. The `loadWalkerUnit` is effectively finished.
        MUTEX_WALKER_UNIT_LOAD.release();
      }
    };

    fetchAll(q, loadWalkerUnit);
  }

  // Overrides autogen's definition
  onClickSurveyUnitAddNewWalkerUnit () {
    String tabgroup = "Survey_Unit";
    if (isNull(getUuid(tabgroup))){
      showToast("{You_must_save_this_tabgroup_first}");
      return;
    }
    parentTabgroup   = tabgroup;
    parentTabgroup__ = tabgroup;
    loadWalkerUnit();
  }

  getZeroableRefs() {
    List   elemNames = new ArrayList(); // names of zeroable elements
    List   refs      = new ArrayList(); // references of zeroable elements
    String fmtRef    = "Walker_Unit/Walker_Unit/%s";

    // 1. Write the element names
    elemNames.add("Ancient");
    elemNames.add("Modern");
    elemNames.add("A_C");
    elemNames.add("Daub");
    elemNames.add("HM");
    elemNames.add("Lithic");
    elemNames.add("Glass");
    elemNames.add("Other");

    // 2. Format the element names into refs
    for (e : elemNames) {
      String ref = replaceFirst(fmtRef, e);
      refs.add(ref);
    }

    return refs;
  }

  zeroIfBlank() {
    for (ref : getZeroableRefs()) {
      zeroIfBlank(ref);
    }
  }

  zeroIfBlank(String ref) {
    String blank = "";
    String zero  = "0";
    String val   = getFieldValue(ref);
    if (blank.equals(val)) {
      setFieldValue(ref, zero);
    }
  }

  blankIfZero(String ref) {
    String blank = "";
    String zero  = "0";
    String val   = getFieldValue(ref);
    if (zero.equals(val)) {
      setFieldValue(ref, blank);
    }
  }

  for (ref : getZeroableRefs()) {
    String focus = "blankIfZero(\"%s\")"; focus = replaceFirst(focus, ref);
    String blur  = "zeroIfBlank(\"%s\")"; blur  = replaceFirst(blur,  ref);

    addOnEvent(ref, "focus", focus);
    addOnEvent(ref, "blur",  blur );
  }

  addOnEvent("Walker_Unit/Walker_Unit/Zero_Row_And_Next_1", "click", "zeroRowAndNext()");
  addOnEvent("Walker_Unit/Walker_Unit/Zero_Row_And_Next_2", "click", "zeroRowAndNext()");
  addOnEvent("Walker_Unit",                                 "show",  "zeroRowAndNextComplete()");
  addOnEvent("Walker_Unit/Walker_Unit/Next_Walker_Unit_1",    "click", "nextWalkerUnit()");
  addOnEvent("Walker_Unit/Walker_Unit/Next_Walker_Unit_2",    "click", "nextWalkerUnit()");

  addOnEvent("Walker_Unit/Walker_Unit/Delete_Row", "click",  "deleteRow      ()");
  addOnEvent("Walker_Unit/Walker_Unit/Up",         "click",  "gridUp         ()");
  addOnEvent("Walker_Unit/Walker_Unit/Down",       "click",  "gridDown       ()");
  addOnEvent("Walker_Unit/Walker_Unit/Left",       "click",  "gridLeft       ()");
  addOnEvent("Walker_Unit/Walker_Unit/Right",      "click",  "gridRight      ()");
  addOnEvent("Walker_Unit/Walker_Unit/Load",       "click",  "loadWalkerUnit ()");
  addOnEvent("Walker_Unit",                        "create", "onCreateWalkerUnit()");
  addOnEvent("Walker_Unit",                        "fetch",  "updateGridDimsVars()");
  addOnEvent("Walker_Unit",                        "show",   "redrawGrid()");
  addOnEvent("Walker_Unit",                        "leave",  "initHighlighted()");

  addOnEvent("Survey_Unit",                        "create", "onCreateSurveyUnit()");

  persistOverSessions("Control/Main/Number_of_Rows");
  persistOverSessions("Control/Main/Number_of_Walkers");

/******************************************************************************/
/*                                    INIT                                    */
/*                                                                            */
/* Stuff which needs to be done last.                                         */
/******************************************************************************/
bindOnEvents();
